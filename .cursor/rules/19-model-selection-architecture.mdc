---
alwaysApply: true
description: Model selection architecture patterns and hierarchical priority system
---

# Model Selection Architecture

## Overview

The application implements a sophisticated model selection system that balances user preferences, persistence, performance, and backward compatibility through a hierarchical priority system.

## Core Architecture Components

### 1. Consolidated Models API - [app/(chat)/api/models/route.ts](<mdc:app/(chat)/api/models/route.ts>)

The models API serves as the single source of truth for both model data and user settings:

```typescript
export const GET = protectedRoute(async (request, context, user) => {
  // Fetch user settings and models in parallel
  const [userSettings, allModels] = await Promise.all([
    getUserSettings(user.id),
    gateway.getAvailableModels(),
  ]);

  return NextResponse.json({
    models: supportedModels,
    userType: user.type,
    userSettings: userSettings?.settings || {}, // Include user settings
  });
});
```

### 2. Models Hook - [hooks/use-models.ts](mdc:hooks/use-models.ts)

Provides access to models and user settings through a single API call:

```typescript
interface ModelsResponse {
  models: ChatModel[];
  userType: "free" | "pro";
  userSettings?: Record<string, any>;
}

export function useModels() {
  const { data, error, isLoading, mutate } = useSWR<ModelsResponse>(
    "/api/models",
    fetcher,
    {
      revalidateOnMount: true,
      refreshInterval: 15 * 60 * 1000, // 15 minutes
      dedupingInterval: 60 * 60 * 1000, // 1 hour
    }
  );

  return {
    models: data?.models ?? [],
    userType: data?.userType ?? "free",
    userSettings: data?.userSettings ?? {},
    isLoading,
    error,
    mutate,
  };
}
```

## Hierarchical Model Selection Priority

### Priority Order (Highest to Lowest)

1. **Props `selectedModelId`** - For backward compatibility and explicit overrides
2. **Server settings model** - Authoritative user preference from database
3. **localStorage model** - Immediate persistence for offline-first experience
4. **Plan-based default** - Ultimate fallback based on user subscription tier

### Implementation in [components/model-picker.tsx](mdc:components/model-picker.tsx)

```typescript
const effectiveModelId = useMemo(() => {
  // 1. Props selectedModelId (backward compatibility)
  if (selectedModelId) {
    const modelExists = allModels.some((model) => model.id === selectedModelId);
    if (modelExists) return selectedModelId;
  }

  // 2. Server settings model (authoritative)
  if (serverModel) {
    const modelExists = allModels.some((model) => model.id === serverModel);
    if (modelExists) return serverModel;
  }

  // 3. localStorage model (immediate persistence)
  if (localModel) {
    const modelExists = allModels.some((model) => model.id === localModel);
    if (modelExists) return localModel;
  }

  // 4. Plan-based default (ultimate fallback)
  return planBasedDefaultModel;
}, [
  selectedModelId,
  serverModel,
  localModel,
  allModels,
  planBasedDefaultModel,
]);
```

## Component Integration Patterns

### ✅ Chat Component Integration

```typescript
// components/chat.tsx
export function Chat({ session, initialChatModel }: ChatProps) {
  // Use integrated models API that includes user settings
  const { userSettings, models } = useModels();

  // Get current model with proper fallback chain
  const currentModel =
    userSettings?.defaultModel ||
    initialChatModel ||
    getDefaultModelForUser(session.user.type);

  // Pass to MultimodalInput which forwards to ModelPicker
  return (
    <MultimodalInput
      selectedModelId={currentModel}
      session={session}
      // ... other props
    />
  );
}
```

### ✅ Model Picker Component

```typescript
// components/model-picker.tsx
export function ModelPicker({
  session,
  selectedModelId, // From Chat component
  className,
  compact = false,
  disabled = false,
}: ModelPickerProps) {
  // Use models API which includes user settings
  const { models: allModels, userSettings, mutate: mutateModels } = useModels();

  // Extract server model from user settings
  const serverModel = userSettings?.defaultModel;

  // Get localStorage model for immediate feedback
  const [localModel, setLocalModel] = useState<string | null>(() =>
    safeLocalStorage.get(MODEL_SELECTION_KEY)
  );

  // Hierarchical model selection logic (shown above)
  const effectiveModelId = useMemo(() => {
    /* ... */
  });

  // Handle model selection with optimistic updates
  const handleModelSelect = async (modelId: string) => {
    setOpen(false);

    // Immediate localStorage update for instant UI feedback
    setLocalModel(modelId);
    safeLocalStorage.set(MODEL_SELECTION_KEY, modelId);

    try {
      // Update user settings via PATCH API
      const response = await fetch("/api/user/settings", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ defaultModel: modelId }),
      });

      if (!response.ok) throw new Error("Failed to update settings");

      // Refresh models data to get updated user settings from server
      await mutateModels();
    } catch (error) {
      console.error("Failed to save model selection to server:", error);
      // Note: localStorage was already updated for immediate feedback
    }
  };
}
```

## localStorage Integration

### Safe localStorage Utilities

```typescript
const MODEL_SELECTION_KEY = "user-model-selection";

const safeLocalStorage = {
  get: (key: string): any => {
    try {
      if (typeof window === "undefined") return null;
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : null;
    } catch (error) {
      console.warn(`Failed to read from localStorage: ${key}`, error);
      return null;
    }
  },
  set: (key: string, value: any): void => {
    try {
      if (typeof window === "undefined") return;
      localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.warn(`Failed to write to localStorage: ${key}`, error);
    }
  },
};
```

### Server ↔ localStorage Synchronization

```typescript
// Sync localStorage with server when server data arrives
useEffect(() => {
  if (serverModel && serverModel !== localModel) {
    setLocalModel(serverModel);
    safeLocalStorage.set(MODEL_SELECTION_KEY, serverModel);
  }
}, [serverModel, localModel]);
```

## User Experience Flow

### Model Selection Process

1. **User selects model** → Immediate localStorage update (instant UI feedback)
2. **PATCH to `/api/user/settings`** → Server persistence
3. **Models API refresh** → Synchronizes server state
4. **localStorage sync** → Ensures consistency

### Page Load/Refresh Process

1. **Load from localStorage** → Instant model display
2. **Fetch from models API** → Includes fresh user settings
3. **Sync localStorage** → Updates with authoritative server data
4. **Fallback to defaults** → If no data available

### Cross-Tab Synchronization

- Model selection persists across browser tabs via localStorage
- Server changes sync to localStorage on next API call
- Consistent state maintained across all application instances

## Migration Patterns

### ❌ Deprecated Pattern

```typescript
// DON'T USE: Separate API calls for models and settings
const { models } = useModels();
const { selectedModel } = useSelectedModel(session); // Separate API call
```

### ✅ Current Pattern

```typescript
// USE: Consolidated API approach
const { models, userSettings } = useModels(); // Single API call
const currentModel = userSettings?.defaultModel || fallback;
```

## Error Handling and Resilience

### API Failure Handling

```typescript
// Models API includes fallback for user settings
try {
  const [userSettings, allModels] = await Promise.all([
    getUserSettings(user.id),
    gateway.getAvailableModels(),
  ]);
  // ... success path
} catch (error) {
  // Try to get user settings even in fallback
  let userSettings = {};
  try {
    const settings = await getUserSettings(user.id);
    userSettings = settings?.settings || {};
  } catch (settingsError) {
    console.error("Failed to get user settings in fallback:", settingsError);
  }

  return NextResponse.json({
    models: fallbackModels,
    userType: user.type,
    userSettings,
    warning: "Using fallback model configuration due to provider error",
  });
}
```

### Offline Resilience

- Model picker works offline using localStorage data
- Server sync resumes when connectivity is restored
- Graceful degradation with plan-based defaults

## Performance Benefits

- **50% reduction in API calls** (from 2 separate to 1 consolidated)
- **Instant UI feedback** via localStorage
- **Consistent state** across all components
- **Reduced race conditions** between API calls
- **Better caching efficiency** with single data source

## Testing Considerations

### Unit Testing Model Selection Logic

```typescript
describe("Model Selection Priority", () => {
  it("should prioritize selectedModelId prop over server model", () => {
    const result = getEffectiveModel({
      selectedModelId: "prop-model",
      serverModel: "server-model",
      localModel: "local-model",
      planDefault: "default-model",
    });
    expect(result).toBe("prop-model");
  });

  it("should fallback to server model when prop not provided", () => {
    const result = getEffectiveModel({
      selectedModelId: null,
      serverModel: "server-model",
      localModel: "local-model",
      planDefault: "default-model",
    });
    expect(result).toBe("server-model");
  });
});
```

### Integration Testing

- Test model selection persistence across page refreshes
- Verify synchronization between localStorage and server
- Test fallback behavior when APIs fail
- Verify cross-tab consistency

This architecture provides a robust, performant, and user-friendly model selection system that balances immediate responsiveness with authoritative server state.
