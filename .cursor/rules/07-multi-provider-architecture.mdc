---
description: AI SDK Gateway architecture for scalable model management with unified configuration and capability-based features
---

# AI SDK Gateway Architecture

## Overview

The application implements a **unified AI SDK Gateway architecture** that replaces custom provider abstractions with direct gateway usage. This provides scalable model management, dynamic capabilities, and server-side security while maintaining clean separation of concerns.

## Core Architecture Principles

### 1. Single Gateway Provider

All AI models (text and image) are accessed through a single gateway configuration:

```typescript
// Reference: lib/gateway.ts - Unified access point
import { createGatewayProvider } from "@ai-sdk/gateway";

export const gateway = createGatewayProvider({});
```

### 2. Unified Model Configuration

Models are defined in a single source of truth with capabilities:

```typescript
// Reference: lib/constants.ts - Single configuration object
export const SUPPORTED_MODELS = {
  "xai/grok-3": {
    supportsReasoning: true,
    supportsArtifacts: true,
  },
  "xai/grok-3-mini": {
    supportsReasoning: true,
    supportsArtifacts: true,
  },
  "openai/gpt-4o-mini": {
    supportsReasoning: false,
    supportsArtifacts: true,
  },
  "anthropic/claude-3.5-haiku": {
    supportsReasoning: false,
    supportsArtifacts: true,
  },
  // ... additional models
} as const;

// Derived constants
export const SUPPORTED_MODEL_IDS = Object.keys(SUPPORTED_MODELS);
export const DEFAULT_MODEL = "xai/grok-3-mini";
export const DEFAULT_IMAGE_MODEL = "xai/grok-2-image-1212";
```

### 3. Helper Functions for Model Management

```typescript
// Reference: lib/constants.ts - Utility functions
export function getModelCapabilities(modelId: string) {
  return (
    SUPPORTED_MODELS[modelId as keyof typeof SUPPORTED_MODELS] || {
      supportsReasoning: false,
      supportsArtifacts: false,
    }
  );
}

export function isModelSupported(modelId: string): boolean {
  return modelId in SUPPORTED_MODELS;
}
```

## Gateway Integration Layer

### 1. Dynamic Model Access

```typescript
// Reference: lib/ai/providers.ts - Gateway wrapper with capabilities
import { gateway } from "@/lib/gateway";
import { getModelCapabilities } from "@/lib/constants";

export const getLanguageModel = (modelId: string) => {
  if (isTestEnvironment) {
    return chatModel; // Test models
  }

  const capabilities = getModelCapabilities(modelId);
  const baseModel = gateway.languageModel(modelId);

  // Apply reasoning middleware based on capabilities
  if (capabilities?.supportsReasoning) {
    return wrapLanguageModel({
      model: baseModel,
      middleware: extractReasoningMiddleware({ tagName: "thinking" }),
    });
  }

  return baseModel;
};

export const modelSupports = (
  modelId: string,
  feature: "reasoning" | "artifacts"
): boolean => {
  const capabilities = getModelCapabilities(modelId);
  return feature === "reasoning"
    ? capabilities.supportsReasoning
    : capabilities.supportsArtifacts;
};
```

### 2. Server-Side Model Enrichment

```typescript
// Reference: lib/ai/models.ts - Gateway model enrichment
export const enrichModelWithCapabilities = (gatewayModel: any): ChatModel => {
  const capabilities = getModelCapabilities(gatewayModel.id);

  return {
    id: gatewayModel.id,
    name: gatewayModel.name || gatewayModel.id,
    description: gatewayModel.description || `${gatewayModel.id} model`,
    provider: gatewayModel.id.split("/")[0] || "unknown",
    supportsReasoning: capabilities.supportsReasoning,
    supportsArtifacts: capabilities.supportsArtifacts,
  };
};
```

## Dynamic API Architecture

### 1. Models API with Server-Side Filtering

```typescript
// Reference: app/(chat)/api/models/route.ts - Real-time model listing
export const GET = withSecurity(async (securityContext) => {
  const allModels = await gateway.getAvailableModels();
  const allowedModelIds = getAllowedModelIdsForUser(securityContext.user.type);

  const supportedModels = allModels.models
    .filter((model) => SUPPORTED_MODEL_IDS.includes(model.id))
    .map((model) => {
      const enrichedModel = enrichModelWithCapabilities(model);
      return {
        ...enrichedModel,
        enabled: allowedModelIds.includes(model.id), // Server-side entitlement
      };
    });

  return NextResponse.json({
    models: supportedModels,
    userType: securityContext.user.type,
  });
});
```

### 2. Enhanced Chat API with Dynamic Configuration

```typescript
// Reference: app/(chat)/api/chat/route.ts - Capability-based configuration
export async function POST(request: Request) {
  const { selectedChatModel } = await request.json();
  const session = await auth();

  // Server-side model access validation
  const allowedModelIds = getAllowedModelIdsForUser(session.user.type);
  validateModelAccess(
    selectedChatModel,
    session.user.type,
    session.user.id,
    allowedModelIds
  );

  // Dynamic model configuration
  const model = getLanguageModel(selectedChatModel);
  const supportsArtifacts = modelSupports(selectedChatModel, "artifacts");
  const supportsReasoning = modelSupports(selectedChatModel, "reasoning");

  const result = await streamText({
    model,
    system: systemPrompt({
      selectedModel: {
        id: selectedChatModel,
        supportsArtifacts,
        supportsReasoning,
      },
      requestHints,
    }),
    experimental_activeTools: supportsArtifacts
      ? ["getWeather", "createDocument", "updateDocument", "requestSuggestions"]
      : ["getWeather"],
    tools: {
      getWeather,
      createDocument: createDocument({ session, dataStream, selectedModel }),
      updateDocument: updateDocument({ session, dataStream, selectedModel }),
      requestSuggestions: requestSuggestions({
        session,
        dataStream,
        selectedModel,
      }),
    },
  });

  return result.toUIMessageStream({
    sendReasoning: supportsReasoning,
  });
}
```

## Enhanced Security Architecture

### 1. Comprehensive Security Middleware

```typescript
// Reference: lib/security.ts - Multi-layer security
export const withSecurity = (
  handler: (securityContext: SecurityContext) => Promise<Response>,
  options?: {
    requireAuth?: boolean;
    rateLimit?: boolean;
    maxRequestSize?: number;
  }
) => {
  return async (request: Request): Promise<Response> => {
    try {
      // Request validation
      validateRequestSize(request, options?.maxRequestSize);

      // Enhanced authentication with DB verification
      const securityContext = await requireAuth();

      // Rate limiting per user
      if (options?.rateLimit && !checkRateLimit(securityContext.user.id)) {
        logSecurityEvent("rate_limit_exceeded", {
          userId: securityContext.user.id,
          userType: securityContext.user.type,
        });
        return new ChatSDKError("rate_limit:api").toResponse();
      }

      return await handler(securityContext);
    } catch (error) {
      if (error instanceof ChatSDKError) {
        return error.toResponse();
      }
      return new ChatSDKError("bad_request:api").toResponse();
    }
  };
};
```

### 2. Model Access Validation with Security Logging

```typescript
// Reference: lib/security.ts - Secure model validation
export function validateModelAccess(
  modelId: string,
  userType: UserType,
  userId: string,
  allowedModelIds: string[]
): void {
  if (!allowedModelIds.includes(modelId)) {
    logSecurityEvent("forbidden_model", {
      userId,
      userType,
      resource: "model_access",
      attemptedValue: modelId,
      allowedValues: allowedModelIds,
    });
    throw new ChatSDKError("forbidden:chat");
  }
}
```

### 3. Enhanced Authentication with DB Verification

```typescript
// Reference: lib/security.ts - Real-time user validation
export async function requireAuth(): Promise<SecurityContext> {
  const session = await auth();

  if (!session?.user?.id) {
    throw new ChatSDKError("unauthorized:chat");
  }

  // Verify user exists in database (for real-time deactivation)
  const dbUser = await getUserById(session.user.id);
  if (!dbUser) {
    throw new ChatSDKError("unauthorized:chat");
  }

  return {
    user: {
      id: session.user.id,
      type: session.user.type,
      email: session.user.email,
    },
    isAuthenticated: true,
  };
}
```

## Dynamic Entitlements System

### 1. Server-Side Model Filtering

```typescript
// Reference: lib/ai/entitlements.ts - Dynamic entitlements
export const entitlementsByUserType: Record<UserType, Entitlements> = {
  guest: {
    maxMessagesPerDay: 20,
    getAllowedModelIds: () => {
      return SUPPORTED_MODEL_IDS.filter(
        (modelId) =>
          modelId.includes("grok-3-mini") ||
          modelId.includes("gpt-3.5") ||
          modelId.includes("gemma2-9b") ||
          modelId.includes("ministral-3b")
      );
    },
  },
  regular: {
    maxMessagesPerDay: 100,
    getAllowedModelIds: () => {
      return SUPPORTED_MODEL_IDS; // All supported models
    },
  },
};

export const getAllowedModelIdsForUser = (
  userType: UserType
): Array<string> => {
  return entitlementsByUserType[userType].getAllowedModelIds();
};
```

### 2. Client-Side Model Display

```typescript
// Reference: hooks/use-models.ts - Server-filtered models
export function useModels() {
  const { data, error, isLoading } = useSWR<ModelsResponse>(
    "/api/models",
    fetcher,
    {
      revalidateOnFocus: false,
      refreshInterval: 5 * 60 * 1000, // Refresh every 5 minutes
    }
  );

  return {
    models: data?.models ?? [],
    userType: data?.userType ?? "guest",
    isLoading,
    error,
  };
}

export function isModelEnabled(model: ChatModel): boolean {
  return model.enabled !== false;
}
```

## Server Actions & Artifact Integration

### 1. Gateway-Based Server Actions

```typescript
// Reference: app/(chat)/actions.ts - Dynamic model usage
export async function generateTitleFromUserMessage({
  message,
}: {
  message: UIMessage;
}) {
  const { text: title } = await generateText({
    model: getLanguageModel(DEFAULT_MODEL), // No hardcoded models
    system: `Generate a short title based on the first message...`,
    prompt: JSON.stringify(message),
  });

  return title;
}
```

### 2. Artifact Handlers with Dynamic Models

```typescript
// Reference: artifacts/text/server.ts - User model selection
export const textDocumentHandler = createDocumentHandler<"text">({
  kind: "text",
  onCreateDocument: async ({ title, dataStream, selectedModel }) => {
    const { fullStream } = streamText({
      model: getLanguageModel(selectedModel.id), // User's chosen model
      system: "Write about the given topic...",
      prompt: title,
    });

    for await (const delta of fullStream) {
      if (delta.type === "text") {
        dataStream.write({
          type: "data-textDelta",
          data: delta.text,
          transient: true,
        });
      }
    }
  },
  onUpdateDocument: async ({ document, description, selectedModel }) => {
    const { fullStream } = streamText({
      model: getLanguageModel(selectedModel.id),
      system: updateDocumentPrompt,
      prompt: `${document.content}\n\nUpdate request: ${description}`,
    });
    // ... update logic
  },
});
```

### 3. Image Generation with Gateway

```typescript
// Reference: artifacts/image/server.ts - Configurable image models
export const imageDocumentHandler = createDocumentHandler<"image">({
  kind: "image",
  onCreateDocument: async ({ title, dataStream }) => {
    const { image } = await experimental_generateImage({
      model: gateway.imageModel(DEFAULT_IMAGE_MODEL), // Configurable
      prompt: title,
      n: 1,
    });

    dataStream.write({
      type: "data-imageDelta",
      data: image.base64,
      transient: true,
    });

    return image.base64;
  },
});
```

## Client-Side Architecture

### 1. Enhanced Model Selector

```typescript
// Reference: components/model-selector.tsx - Server-filtered models
export function ModelSelector({
  session,
  selectedModelId,
}: ModelSelectorProps) {
  const { models: allModels, isLoading } = useModels();

  return (
    <DropdownMenuContent>
      {allModels.map((chatModel) => {
        const enabled = isModelEnabled(chatModel);

        return (
          <DropdownMenuItem
            key={chatModel.id}
            disabled={!enabled}
            onSelect={() => {
              if (!enabled) return; // Prevent disabled model selection
              saveChatModelAsCookie(chatModel.id);
            }}
          >
            <div className="flex flex-col gap-1">
              <div className="flex items-center gap-2">
                {chatModel.name}
                {!enabled && (
                  <span className="text-xs px-1.5 py-0.5 bg-muted rounded">
                    Pro
                  </span>
                )}
              </div>
              <div className="text-xs text-muted-foreground">
                {chatModel.description}
              </div>
            </div>
          </DropdownMenuItem>
        );
      })}
    </DropdownMenuContent>
  );
}
```

### 2. Chat Integration with Dynamic Models

```typescript
// Reference: components/chat.tsx - Model-aware chat
const { messages, sendMessage, status } = useChat<ChatMessage>({
  id,
  messages: initialMessages,
  transport: new DefaultChatTransport({
    api: "/api/chat",
    prepareSendMessagesRequest({ messages, id, body }) {
      return {
        body: {
          id,
          message: messages.at(-1),
          selectedChatModel: selectedChatModel, // Dynamic model selection
          selectedVisibilityType: visibilityType,
          ...body,
        },
      };
    },
  }),
});
```

## Adding New Models

### Step-by-Step Process

1. **Add to unified configuration**:

```typescript
// lib/constants.ts
export const SUPPORTED_MODELS = {
  // ... existing models
  "anthropic/claude-3.5-sonnet": {
    supportsReasoning: true,
    supportsArtifacts: true,
  },
} as const;
```

2. **Update entitlements** (if needed):

```typescript
// lib/ai/entitlements.ts
regular: {
  getAllowedModelIds: () => {
    return SUPPORTED_MODEL_IDS.filter(modelId =>
      !modelId.includes('premium-model') // Filter expensive models
    );
  },
},
```

3. **Test the integration**:

```typescript
// Verify model capabilities
expect(modelSupports("anthropic/claude-3.5-sonnet", "reasoning")).toBe(true);
expect(isModelSupported("anthropic/claude-3.5-sonnet")).toBe(true);
```

## Performance & Scalability

### 1. Efficient Model Loading

- **Lazy loading**: Gateway models loaded on-demand
- **Caching**: Model configurations cached in constants
- **Real-time updates**: Fresh model availability via gateway API
- **Type safety**: TypeScript ensures configuration consistency

### 2. Security Optimizations

- **Server-side filtering**: No client-side model enumeration
- **Rate limiting**: Per-user request throttling
- **Security logging**: Comprehensive audit trail
- **DB verification**: Real-time user validation

### 3. Cost Management

- **User-based entitlements**: Control expensive model access
- **Model capability awareness**: Optimize tool usage
- **Usage tracking**: Monitor per-model consumption
- **Fallback strategies**: Graceful degradation

## Testing Gateway Architecture

### 1. Model Configuration Tests

```typescript
describe("Gateway Architecture", () => {
  it("should provide correct model capabilities", () => {
    expect(modelSupports("xai/grok-3-mini", "reasoning")).toBe(true);
    expect(modelSupports("openai/gpt-3.5-turbo", "artifacts")).toBe(false);
  });

  it("should validate model support", () => {
    expect(isModelSupported("xai/grok-3-mini")).toBe(true);
    expect(isModelSupported("invalid-model")).toBe(false);
  });
});
```

### 2. Security Tests

```typescript
describe("Security Integration", () => {
  it("should validate model access", () => {
    expect(() =>
      validateModelAccess("premium-model", "guest", "user-id", ["basic-model"])
    ).toThrow(ChatSDKError);
  });

  it("should enforce rate limits", async () => {
    // Simulate rate limit exceeded
    for (let i = 0; i < 101; i++) {
      await checkRateLimit("user-id");
    }
    expect(checkRateLimit("user-id")).toBe(false);
  });
});
```

### 3. API Integration Tests

```typescript
describe("API Gateway Integration", () => {
  it("should return filtered models for user type", async () => {
    const response = await GET(createAuthenticatedRequest("guest"));
    const data = await response.json();

    expect(data.models.every((m) => m.id.includes("basic"))).toBe(true);
    expect(data.userType).toBe("guest");
  });
});
```

## Migration Benefits

### From Custom Provider to Gateway

1. **Simplified Architecture**: Direct gateway usage instead of custom abstractions
2. **Enhanced Security**: Server-side filtering with comprehensive logging
3. **Real-time Models**: Fresh model availability from gateway
4. **Type Safety**: Unified configuration prevents inconsistencies
5. **Better UX**: Server-filtered models with enabled/disabled states
6. **Scalability**: Easy to add new models and providers

### Key Advantages

- ✅ **No Provider Abstractions**: Direct AI SDK Gateway usage
- ✅ **Unified Configuration**: Single source of truth for models
- ✅ **Server-Side Security**: Authentication, validation, and logging
- ✅ **Dynamic Capabilities**: Features based on model capabilities
- ✅ **Real-time Updates**: Models refreshed from gateway API
- ✅ **Enhanced UX**: Clear upgrade paths for users
