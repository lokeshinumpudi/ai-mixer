---
alwaysApply: true
description: "Covers Supabase integration, anonymous users, and user data synchronization."
---

# 02: Authentication System

## Core Architecture

The system uses **Supabase Authentication** as the primary identity provider with a **CLEAN, DIRECT APPROACH**. User records in the local PostgreSQL database use Supabase user IDs directly as database primary keys, eliminating complex linking logic.

### Authentication Flow

1.  User authenticates with Supabase (e.g., via Google OAuth).
2.  A JWT is issued and managed by Supabase middleware.
3.  On the first API request, the `authenticatedRoute` or `protectedRoute` decorator is invoked.
4.  The decorator calls `createOAuthUserIfNotExistsSimple` to ensure the user exists in the local database.
5.  All operations use the Supabase user ID directly as the database primary key.

## CLEAN User Identity Management

**✅ SIMPLIFIED APPROACH**: **Supabase IDs are used directly as database primary keys**. No complex linking required.

### ✅ CLEAN: Direct Mapping Approach (CURRENT)

```typescript
// lib/db/queries.ts
export async function createOAuthUserIfNotExistsSimple(
  supabaseUserId: string,
  email: string
) {
  // Check if user already exists
  const [existingUser] = await db
    .select()
    .from(user)
    .where(eq(user.id, supabaseUserId))
    .limit(1);

  if (existingUser) {
    return existingUser; // User already exists
  }

  // Create new user with Supabase ID as primary key
  const [newUser] = await db
    .insert(user)
    .values({
      id: supabaseUserId, // Direct mapping - no translation needed
      email,
    })
    .returning();

  return newUser;
}
```

### Why This Approach is Clean

- ✅ **Zero Complexity**: No legacy user handling
- ✅ **Direct Mapping**: Supabase ID = Database ID
- ✅ **Simple Logic**: Single database lookup
- ✅ **Future-Proof**: Works with fresh database
- ✅ **No Edge Cases**: Clean state from day one

## Anonymous User Support

The application provides a seamless experience for anonymous (guest) users.

- **Creation**: Anonymous sessions are initiated via `supabase.auth.signInAnonymously()`.
- **Identification**: The `user` object from auth decorators includes an `is_anonymous` flag.
- **Limitations**: Anonymous users have different entitlements, such as lower message quotas and access to fewer AI models, which are enforced server-side.
- **Data Migration**: When an anonymous user signs up, their data (e.g., chat history) should be migrated and associated with their new authenticated user account.
- **Current Implementation Note**: Anonymous sessions are persisted to the local DB for usage/rate-limiting by calling `createAnonymousUserIfNotExists(user.id)` in `app/(chat)/api/chat/route.ts`. This creates a `User` row with a placeholder email. If we decide to avoid local records for guests in the future, we must first relax the `User.email` NOT NULL constraint and refactor usage tracking to be solely session-based.
