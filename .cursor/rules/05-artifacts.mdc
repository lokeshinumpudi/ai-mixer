---
description: Artifacts system patterns with chat-scoped state management for generating and editing code, text, images, and spreadsheets
---

# Artifacts System Architecture

## Overview

The artifacts system enables real-time generation and editing of different content types (text, code, images, spreadsheets) with live preview, version control, collaborative editing features, and **chat-scoped state management**.

## Core Architecture

### Artifact Types

- **Text** - Rich text documents with markdown support
- **Code** - Interactive code editor with syntax highlighting and execution
- **Image** - Image generation and editing capabilities
- **Sheet** - Spreadsheet functionality with data manipulation

### Directory Structure

```
artifacts/
├── actions.ts          # Server actions for artifacts
├── text/
│   ├── client.tsx      # Text artifact client component
│   └── server.ts       # Text artifact server handler
├── code/
│   ├── client.tsx      # Code editor client component
│   └── server.ts       # Code artifact server handler
├── image/
│   ├── client.tsx      # Image editor client component
│   └── server.ts       # Image artifact server handler
└── sheet/
    ├── client.tsx      # Spreadsheet client component
    └── server.ts       # Sheet artifact server handler
```

## Chat-Scoped State Management

### Problem Solved

Previously, artifact state was global and persisted across chat sessions, causing artifacts to unexpectedly appear when switching chats. Now each chat session has isolated artifact state.

### Implementation Pattern

```typescript
// Reference: hooks/use-artifact.ts - Chat-scoped state
export function useArtifact(chatId?: string) {
  const artifactKey = chatId ? `artifact-${chatId}` : "artifact";
  const { data: localArtifact, mutate: setLocalArtifact } = useSWR<UIArtifact>(
    artifactKey,
    null,
    {
      fallbackData: initialArtifactData,
    }
  );

  // Rest of hook implementation...
}

// Usage in components
const { artifact, setArtifact } = useArtifact(chatId);
```

### ChatId Extraction Pattern

```typescript
// Reference: components/data-stream-handler.tsx
export function DataStreamHandler() {
  const pathname = usePathname();

  // Extract chatId from pathname (e.g., /chat/123 -> 123)
  const chatId = pathname.startsWith("/chat/") ? pathname.slice(6) : undefined;

  const { artifact, setArtifact, setMetadata } = useArtifact(chatId);
  // Component logic...
}
```

### State Isolation Benefits

1. **Clean navigation** - Closing artifacts in one chat doesn't affect others
2. **Session persistence** - Each chat maintains its own artifact state
3. **No state leakage** - Switching chats doesn't show artifacts from previous sessions
4. **Proper cleanup** - Artifacts are scoped and managed per chat context

## Artifact Definition Pattern

### Enhanced Client-Side Structure

```typescript
// Reference: artifacts/code/client.tsx - Auto-visibility pattern
export const codeArtifact = new Artifact<"code", Metadata>({
  kind: "code",
  description:
    "Useful for code generation; Code execution is only available for python code.",
  initialize: async ({ setMetadata }) => {
    setMetadata({
      outputs: [],
    });
  },
  onStreamPart: ({ streamPart, setArtifact }) => {
    if (streamPart.type === "data-codeDelta") {
      setArtifact((draftArtifact) => ({
        ...draftArtifact,
        content: streamPart.data,
        // Auto-visibility based on content length
        isVisible:
          draftArtifact.status === "streaming" &&
          draftArtifact.content.length > 300 &&
          draftArtifact.content.length < 310
            ? true
            : draftArtifact.isVisible,
        status: "streaming",
      }));
    }
  },
  content: ({ metadata, setMetadata, ...props }) => {
    return (
      <>
        <div className="px-1">
          <CodeEditor {...props} />
        </div>
        {metadata?.outputs && (
          <Console
            consoleOutputs={metadata.outputs}
            setConsoleOutputs={() => {
              setMetadata({
                ...metadata,
                outputs: [],
              });
            }}
          />
        )}
      </>
    );
  },
  // Actions and toolbar configuration...
});
```

### Auto-Visibility Thresholds

Different artifact types have different visibility thresholds:

```typescript
// Text artifacts - 400+ characters
isVisible:
  draftArtifact.status === 'streaming' &&
  draftArtifact.content.length > 400 &&
  draftArtifact.content.length < 450
    ? true
    : draftArtifact.isVisible,

// Code artifacts - 300+ characters
isVisible:
  draftArtifact.status === 'streaming' &&
  draftArtifact.content.length > 300 &&
  draftArtifact.content.length < 310
    ? true
    : draftArtifact.isVisible,
```

## Core Components

### Enhanced Artifact Container

```typescript
// Reference: components/artifact.tsx - Chat-scoped implementation
function PureArtifact({
  chatId,
  input,
  setInput,
  status,
  stop,
  attachments,
  setAttachments,
  sendMessage,
  messages,
  setMessages,
  regenerate,
  votes,
  isReadonly,
  selectedVisibilityType,
  session,
  selectedModelId,
}: ArtifactProps) {
  // Chat-scoped artifact state
  const { artifact, setArtifact, metadata, setMetadata } = useArtifact(chatId);

  // Document management with SWR
  const {
    data: documents,
    isLoading: isDocumentsFetching,
    mutate: mutateDocuments,
  } = useSWR<Array<Document>>(
    artifact.documentId !== "init" && artifact.status !== "streaming"
      ? `/api/document?id=${artifact.documentId}`
      : null,
    fetcher
  );

  // Artifact definition lookup
  const artifactDefinition = artifactDefinitions.find(
    (definition) => definition.kind === artifact.kind
  );

  // Version control and editing logic...

  return (
    <AnimatePresence>
      {artifact.isVisible && (
        <motion.div
          data-testid="artifact"
          className="flex flex-row h-dvh w-dvw fixed top-0 left-0 z-50 bg-transparent"
          initial={{ opacity: 1 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0, transition: { delay: 0.4 } }}
        >
          {/* Artifact content and UI */}
        </motion.div>
      )}
    </AnimatePresence>
  );
}
```

### Artifact Close Button

```typescript
// Reference: components/artifact-close-button.tsx - Chat-aware closing
function PureArtifactCloseButton() {
  const pathname = usePathname();
  const chatId = pathname.startsWith("/chat/") ? pathname.slice(6) : undefined;
  const { setArtifact } = useArtifact(chatId);

  return (
    <Button
      data-testid="artifact-close-button"
      variant="outline"
      className="h-fit p-2 dark:hover:bg-zinc-700"
      onClick={() => {
        setArtifact((currentArtifact) =>
          currentArtifact.status === "streaming"
            ? {
                ...currentArtifact,
                isVisible: false,
              }
            : { ...initialArtifactData, status: "idle" }
        );
      }}
    >
      <CrossIcon size={18} />
    </Button>
  );
}
```

## State Management Interface

### UIArtifact Interface

```typescript
// Reference: components/artifact.tsx
export interface UIArtifact {
  title: string;
  documentId: string;
  kind: ArtifactKind;
  content: string;
  isVisible: boolean; // Controls artifact visibility
  status: "streaming" | "idle"; // Streaming state
  boundingBox: {
    // Position for animations
    top: number;
    left: number;
    width: number;
    height: number;
  };
}

export const initialArtifactData: UIArtifact = {
  documentId: "init",
  content: "",
  kind: "text",
  title: "",
  status: "idle",
  isVisible: false, // Default to hidden
  boundingBox: {
    top: 0,
    left: 0,
    width: 0,
    height: 0,
  },
};
```

### Metadata Management

```typescript
// Chat-scoped metadata with document association
const { data: localArtifactMetadata, mutate: setLocalArtifactMetadata } =
  useSWR<any>(
    () =>
      artifact.documentId && artifact.documentId !== "init"
        ? `artifact-metadata-${artifact.documentId}`
        : null,
    null,
    {
      fallbackData: null,
    }
  );
```

## Artifact Type Implementations

### Text Artifacts with Suggestions

```typescript
// Reference: artifacts/text/client.tsx
export const textArtifact = new Artifact<"text", TextArtifactMetadata>({
  kind: "text",
  description: "Useful for text content, like drafting essays and emails.",
  initialize: async ({ documentId, setMetadata }) => {
    const suggestions = await getSuggestions({ documentId });
    setMetadata({
      suggestions,
    });
  },
  onStreamPart: ({ streamPart, setMetadata, setArtifact }) => {
    if (streamPart.type === "data-suggestion") {
      setMetadata((metadata) => {
        return {
          suggestions: [...metadata.suggestions, streamPart.data],
        };
      });
    }

    if (streamPart.type === "data-textDelta") {
      setArtifact((draftArtifact) => {
        return {
          ...draftArtifact,
          content: draftArtifact.content + streamPart.data,
          isVisible:
            draftArtifact.status === "streaming" &&
            draftArtifact.content.length > 400 &&
            draftArtifact.content.length < 450
              ? true
              : draftArtifact.isVisible,
          status: "streaming",
        };
      });
    }
  },
  // Content component implementation...
});
```

### Code Artifacts with Execution

```typescript
// Reference: artifacts/code/client.tsx - Enhanced with console output
interface Metadata {
  outputs: Array<ConsoleOutput>;
}

export const codeArtifact = new Artifact<"code", Metadata>({
  kind: "code",
  description:
    "Useful for code generation; Code execution is only available for python code.",
  content: ({ metadata, setMetadata, ...props }) => {
    return (
      <>
        <div className="px-1">
          <CodeEditor {...props} />
        </div>
        {metadata?.outputs && (
          <Console
            consoleOutputs={metadata.outputs}
            setConsoleOutputs={() => {
              setMetadata({
                ...metadata,
                outputs: [],
              });
            }}
          />
        )}
      </>
    );
  },
  actions: [
    {
      icon: <PlayIcon size={18} />,
      label: "Run",
      action: async ({ content, setMetadata, metadata }) => {
        // Execute code and capture output
        const output = await executeCode(content);
        setMetadata({
          ...metadata,
          outputs: [...metadata.outputs, output],
        });
      },
    },
  ],
});
```

## Data Streaming Integration

### Enhanced Stream Handler

```typescript
// Reference: components/data-stream-handler.tsx - Chat-scoped streaming
export function DataStreamHandler() {
  const { dataStream } = useDataStream();
  const pathname = usePathname();

  // Extract chatId from pathname (e.g., /chat/123 -> 123)
  const chatId = pathname.startsWith("/chat/") ? pathname.slice(6) : undefined;

  const { artifact, setArtifact, setMetadata } = useArtifact(chatId);
  const lastProcessedIndex = useRef(-1);

  useEffect(() => {
    if (!dataStream?.length) return;

    const newDeltas = dataStream.slice(lastProcessedIndex.current + 1);
    lastProcessedIndex.current = dataStream.length - 1;

    newDeltas.forEach((delta) => {
      const artifactDefinition = artifactDefinitions.find(
        (artifactDefinition) => artifactDefinition.kind === artifact.kind
      );

      // Let artifact handle stream part
      if (artifactDefinition?.onStreamPart) {
        artifactDefinition.onStreamPart({
          streamPart: delta,
          setArtifact,
          setMetadata,
        });
      }

      // Handle common stream data types
      setArtifact((draftArtifact) => {
        if (delta.type === "data-clear") {
          return { ...initialArtifactData, status: "streaming" };
        }

        switch (delta.type) {
          case "data-id":
            return {
              ...draftArtifact,
              documentId: delta.data,
              status: "streaming",
            };
          case "data-title":
            return {
              ...draftArtifact,
              title: delta.data,
              status: "streaming",
            };
          case "data-kind":
            return {
              ...draftArtifact,
              kind: delta.data,
              status: "streaming",
            };
          case "data-finish":
            return {
              ...draftArtifact,
              status: "idle",
            };
          default:
            return draftArtifact;
        }
      });
    });
  }, [dataStream, artifact, setArtifact, setMetadata]);

  return null;
}
```

### Stream Data Types

```typescript
// Artifact-specific stream data types
type ArtifactStreamData =
  | { type: "data-textDelta"; data: string; transient: true }
  | { type: "data-codeDelta"; data: string; transient: true }
  | { type: "data-suggestion"; data: Suggestion; transient: true }
  | { type: "data-kind"; data: ArtifactKind; transient: true }
  | { type: "data-id"; data: string; transient: true }
  | { type: "data-title"; data: string; transient: true }
  | { type: "data-clear"; data: null; transient: true }
  | { type: "data-finish"; data: null; transient: true };
```

## Document Interaction Patterns

### Click-to-Open Artifacts

```typescript
// Reference: components/document-preview.tsx - Chat-aware opening
const PureHitboxLayer = ({
  hitboxRef,
  result,
  setArtifact,
}: {
  hitboxRef: React.RefObject<HTMLDivElement>;
  result: any;
  setArtifact: (
    updaterFn: UIArtifact | ((currentArtifact: UIArtifact) => UIArtifact)
  ) => void;
}) => {
  const handleClick = useCallback(
    (event: MouseEvent<HTMLElement>) => {
      const boundingBox = event.currentTarget.getBoundingClientRect();

      setArtifact((artifact) =>
        artifact.status === "streaming"
          ? { ...artifact, isVisible: true }
          : {
              ...artifact,
              title: result.title,
              documentId: result.id,
              kind: result.kind,
              isVisible: true, // Make visible on click
              boundingBox: {
                left: boundingBox.x,
                top: boundingBox.y,
                width: boundingBox.width,
                height: boundingBox.height,
              },
            }
      );
    },
    [setArtifact, result]
  );

  return (
    <div
      className="size-full absolute top-0 left-0 rounded-xl z-10"
      ref={hitboxRef}
      onClick={handleClick}
      role="presentation"
      aria-hidden="true"
    >
      {/* Fullscreen icon overlay */}
    </div>
  );
};
```

## Version Control & Collaboration

### Document Versioning with Chat Context

```typescript
// Automatic versioning on content changes - scoped to chat
const debouncedSave = useDebounceCallback((content: string) => {
  updateDocumentContent({
    id: artifact.documentId,
    content,
    version: Date.now(),
    chatId, // Associate with specific chat
  });
}, 1000);
```

### Suggestion System

```typescript
// Reference: lib/db/schema.ts - suggestion table
export const suggestion = pgTable("Suggestion", {
  id: uuid("id").notNull().defaultRandom(),
  documentId: uuid("documentId").notNull(),
  originalText: text("originalText").notNull(),
  suggestedText: text("suggestedText").notNull(),
  description: text("description"),
  isResolved: boolean("isResolved").notNull().default(false),
  userId: uuid("userId")
    .notNull()
    .references(() => user.id),
  createdAt: timestamp("createdAt").notNull(),
});
```

## Performance & UX Considerations

### Chat-Scoped Performance

```typescript
// Debounced auto-save with chat context
const debouncedSave = useDebounceCallback((content: string) => {
  // Save to database with chat association
  updateDocument({
    id: artifact.documentId,
    content,
    chatId,
  });
}, 1000); // 1 second delay
```

### Memory Management

```typescript
// Clean up artifact state when leaving chat
useEffect(() => {
  return () => {
    // Optional: Clean up resources when component unmounts
    if (artifact.documentId !== "init") {
      // Cleanup heavy resources, but keep state for return visits
    }
  };
}, [chatId]);
```

### State Persistence Strategy

1. **Session storage** - Artifacts persist within chat session
2. **Cross-session** - State restored when returning to same chat
3. **Cleanup** - Old artifact states can be garbage collected
4. **Isolation** - No cross-chat state contamination

## Testing Chat-Scoped Artifacts

### State Isolation Testing

```typescript
describe("Chat-Scoped Artifacts", () => {
  it("should isolate artifact state between chats", () => {
    // Create artifact in chat1
    const chat1Hook = renderHook(() => useArtifact("chat1"));
    act(() => {
      chat1Hook.result.current.setArtifact((prev) => ({
        ...prev,
        isVisible: true,
        title: "Chat 1 Artifact",
      }));
    });

    // Create artifact in chat2
    const chat2Hook = renderHook(() => useArtifact("chat2"));

    // Should have separate state
    expect(chat1Hook.result.current.artifact.title).toBe("Chat 1 Artifact");
    expect(chat2Hook.result.current.artifact.title).toBe("");
    expect(chat2Hook.result.current.artifact.isVisible).toBe(false);
  });

  it("should persist state within same chat", () => {
    const { result: hook1 } = renderHook(() => useArtifact("chat1"));
    act(() => {
      hook1.current.setArtifact((prev) => ({
        ...prev,
        isVisible: true,
        content: "Test content",
      }));
    });

    // Re-render with same chatId
    const { result: hook2 } = renderHook(() => useArtifact("chat1"));
    expect(hook2.current.artifact.content).toBe("Test content");
    expect(hook2.current.artifact.isVisible).toBe(true);
  });
});
```

### Integration Testing

```typescript
// Test full artifact workflow with chat scoping
it("should handle artifact lifecycle within chat context", async () => {
  const chatId = "test-chat-123";

  // Navigate to specific chat
  render(<ChatPage chatId={chatId} />);

  // Trigger artifact creation
  await user.type(screen.getByRole("textbox"), "Create a todo list");
  await user.click(screen.getByRole("button", { name: /send/i }));

  // Artifact should appear
  await waitFor(() => {
    expect(screen.getByTestId("artifact")).toBeInTheDocument();
  });

  // Close artifact
  await user.click(screen.getByTestId("artifact-close-button"));

  // Navigate away and back
  navigate("/");
  navigate(`/chat/${chatId}`);

  // Artifact should remain closed
  expect(screen.queryByTestId("artifact")).not.toBeInTheDocument();
});
```
