---
alwaysApply: true
description: Database query organization and separation of concerns
---

# Database Query Organization Rules

## Core Principle: Centralized Database Operations

All database queries MUST be placed in [lib/db/queries.ts](mdc:lib/db/queries.ts) and imported into other files. Never write raw database queries directly in route handlers, server actions, or other server components.

## ✅ Correct Pattern

### In lib/db/queries.ts

```typescript
export async function getUserSubscriptionStatus(userId: string) {
  try {
    const [userSubscription] = await db
      .select()
      .from(subscription)
      .where(eq(subscription.userId, userId))
      .limit(1);

    return (
      userSubscription?.plan === "pro" && userSubscription?.status === "active"
    );
  } catch (error) {
    throw new ChatSDKError(
      "bad_request:database",
      "Failed to get subscription status"
    );
  }
}
```

### In API routes (app/(chat)/api/\*/route.ts)

```typescript
import { getUserSubscriptionStatus } from "@/lib/db/queries";

export async function GET() {
  const session = await auth();
  const isProUser = await getUserSubscriptionStatus(session.user.id);

  return NextResponse.json({ isProUser });
}
```

## ❌ Incorrect Pattern - DO NOT DO THIS

### Never write queries directly in routes

```typescript
// ❌ BAD - Database logic mixed with route logic
export async function GET() {
  const session = await auth();

  // ❌ This should be in queries.ts
  const [userSubscription] = await db
    .select()
    .from(subscription)
    .where(eq(subscription.userId, session.user.id))
    .limit(1);

  return NextResponse.json({ subscription: userSubscription });
}
```

## Database Query Guidelines

### Function Naming Conventions

- `get*` for SELECT operations: `getUserById`, `getChatsByUserId`
- `create*` for INSERT operations: `createUser`, `createChat`
- `update*` for UPDATE operations: `updateChatTitle`, `updateUserProfile`
- `delete*` for DELETE operations: `deleteChatById`, `deleteMessagesByChatId`
- `upsert*` for INSERT/UPDATE operations: `upsertDailyUsage`, `upsertSubscription`

### Error Handling Pattern

```typescript
export async function getExampleData(id: string) {
  try {
    return await db.select().from(table).where(eq(table.id, id));
  } catch (error) {
    throw new ChatSDKError(
      "bad_request:database",
      "Failed to get example data"
    );
  }
}
```

### Type Safety

- Always use proper TypeScript types from schema: `type User = InferSelectModel<typeof user>`
- Return typed results from query functions
- Use Drizzle's type-safe query builder

### Query Organization in queries.ts

Group related functions together:

```typescript
// User Management
export async function getUser(email: string) {
  /* */
}
export async function getUserById(id: string) {
  /* */
}
export async function createUser(email: string, password: string) {
  /* */
}

// Chat Operations
export async function saveChat({ id, userId, title }: ChatParams) {
  /* */
}
export async function getChatsByUserId({ id }: { id: string }) {
  /* */
}
export async function deleteChatById({ id }: { id: string }) {
  /* */
}

// User Settings Management
export async function getUserSettings(userId: string) {
  try {
    const [settings] = await db
      .select()
      .from(userSettings)
      .where(eq(userSettings.userId, userId))
      .limit(1);

    return settings;
  } catch (error) {
    throw new ChatSDKError(
      "bad_request:database",
      "Failed to get user settings"
    );
  }
}

export async function upsertUserSettings(
  userId: string,
  settings: Record<string, any>
) {
  try {
    await db
      .insert(userSettings)
      .values({
        userId,
        settings,
        updatedAt: new Date(),
      })
      .onConflictDoUpdate({
        target: userSettings.userId,
        set: {
          settings,
          updatedAt: new Date(),
        },
      });

    return { success: true };
  } catch (error) {
    throw new ChatSDKError(
      "bad_request:database",
      "Failed to upsert user settings"
    );
  }
}

export async function updateUserSetting(
  userId: string,
  key: string,
  value: any
) {
  try {
    // Get current settings and merge with updates
    const currentSettings = await getUserSettings(userId);
    const updatedSettings = {
      ...currentSettings?.settings,
      [key]: value,
    };

    return await upsertUserSettings(userId, updatedSettings);
  } catch (error) {
    throw new ChatSDKError(
      "bad_request:database",
      "Failed to update user setting"
    );
  }
}

// Usage Tracking
export async function upsertDailyUsage(params: DailyUsageParams) {
  /* */
}
export async function getUserUsageAndLimits(params: UsageParams) {
  /* */
}
```

## Benefits of This Pattern

1. **Single Source of Truth**: All database logic centralized in one file
2. **Reusability**: Query functions can be shared across multiple routes/components
3. **Testing**: Easier to unit test database operations in isolation
4. **Maintenance**: Schema changes only require updates in queries.ts
5. **Type Safety**: Centralized type definitions and error handling
6. **Performance**: Consistent query patterns and optimization opportunities

## Import Pattern

Always import specific functions from queries.ts:

```typescript
import {
  getUserById,
  getUserUsageAndLimits,
  upsertDailyUsage,
} from "@/lib/db/queries";
```

## Exception Cases

The only acceptable database operations outside of queries.ts are:

1. **Database migrations** in [lib/db/migrate.ts](mdc:lib/db/migrate.ts)
2. **Schema definitions** in [lib/db/schema.ts](mdc:lib/db/schema.ts)
3. **Database connection setup** in [lib/db/utils.ts](mdc:lib/db/utils.ts)

**Note**: User settings are considered core business logic and should be managed through the centralized queries.ts file, even though they represent user-specific configuration data rather than traditional "queries".

## Review Checklist

Before committing code, ensure:

- [ ] No raw database queries in route files
- [ ] All DB operations use functions from queries.ts
- [ ] New query functions follow naming conventions
- [ ] Proper error handling with ChatSDKError
- [ ] TypeScript types are properly used
- [ ] Functions are grouped logically in queries.ts
