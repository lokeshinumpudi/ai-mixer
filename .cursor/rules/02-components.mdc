---
description: Component patterns, UI conventions, React best practices, and context handling patterns
---

# Component Patterns & UI Conventions

## Component Structure

### File Organization

- **One component per file** with same name as filename
- **Co-locate related components** in subdirectories when needed
- **Index files** for clean re-exports when appropriate
- **UI components** in [components/ui/](mdc:components/ui/) following shadcn/ui patterns

### Component Patterns

```typescript
// Standard component structure
"use client"; // Only when needed for interactivity

import { type ComponentProps } from "react";
// External imports first
// Internal imports grouped by domain
// Relative imports last

interface ComponentNameProps {
  // Props interface with clear documentation
}

export function ComponentName({ prop1, prop2 }: ComponentNameProps) {
  // Hooks at the top
  // Event handlers
  // Render logic

  return <div className="semantic-class-names">{/* Content */}</div>;
}
```

## UI Component Guidelines

### shadcn/ui Integration

- **Base components** in [components/ui/](mdc:components/ui/) folder
- **Composite components** build upon base components
- **Consistent theming** using CSS variables and Tailwind config
- **Accessibility** built-in with Radix UI primitives

### Styling Conventions

- **Tailwind CSS** for all styling with semantic class names
- **CSS variables** for theme consistency defined in [globals.css](mdc:app/globals.css)
- **Responsive design** with mobile-first approach
- **Dark mode support** using next-themes

Example component:

```typescript
// Reference: components/chat-header.tsx
export function ChatHeader({
  chatId,
  selectedModelId,
  isReadonly,
}: ChatHeaderProps) {
  return (
    <header className="flex items-center justify-between p-4 border-b">
      <ModelSelector modelId={selectedModelId} />
      <VisibilitySelector chatId={chatId} />
    </header>
  );
}
```

## Context & Navigation Patterns

### URL-Based Context Extraction

Many components need to access the current chat ID or route context. Use a consistent pattern for extracting this information.

```typescript
// Reference: components/data-stream-handler.tsx
import { usePathname } from "next/navigation";

export function ComponentNeedingChatId() {
  const pathname = usePathname();

  // Extract chatId from pathname (e.g., /chat/123 -> 123)
  const chatId = pathname.startsWith("/chat/") ? pathname.slice(6) : undefined;

  // Use chatId for context-specific operations
  const { artifact, setArtifact } = useArtifact(chatId);

  return <div>{/* Component content */}</div>;
}
```

### Chat Context Provider Pattern

For components that need extensive chat context, consider using a provider pattern.

```typescript
// Example chat context provider
const ChatContext = createContext<{
  chatId: string;
  isReadonly: boolean;
  session: Session;
} | null>(null);

export function useChatContext() {
  const context = useContext(ChatContext);
  if (!context) {
    throw new Error("useChatContext must be used within ChatProvider");
  }
  return context;
}

export function ChatProvider({
  children,
  chatId,
  isReadonly,
  session,
}: ChatProviderProps) {
  return (
    <ChatContext.Provider value={{ chatId, isReadonly, session }}>
      {children}
    </ChatContext.Provider>
  );
}
```

## State Management Patterns

### Local State

- **useState** for component-specific state
- **useReducer** for complex state logic
- **useRef** for mutable values and DOM references
- **Custom hooks** for reusable stateful logic

### Server State with SWR

```typescript
// Reference: components/chat.tsx
import useSWR from "swr";
import { fetcher } from "@/lib/utils";

const { data: votes } = useSWR<Array<Vote>>(
  messages.length >= 2 ? `/api/vote?chatId=${id}` : null,
  fetcher
);
```

### Chat-Scoped State Pattern

For state that should be isolated per chat session:

```typescript
// Reference: hooks/use-artifact.ts
export function useArtifact(chatId?: string) {
  const artifactKey = chatId ? `artifact-${chatId}` : "artifact";
  const { data: artifact, mutate: setArtifact } = useSWR<UIArtifact>(
    artifactKey,
    null,
    { fallbackData: initialArtifactData }
  );

  return { artifact, setArtifact };
}
```

### Custom Hooks Pattern

```typescript
// Reference: hooks/use-artifact.ts
export function useArtifact() {
  const [artifact, setArtifact] = useState<UIArtifact>({
    // Initial state
  });

  const [metadata, setMetadata] = useState<ArtifactMetadata>({
    // Initial metadata
  });

  return {
    artifact,
    setArtifact,
    metadata,
    setMetadata,
  };
}
```

## Form Handling

### Input Components

- **Controlled components** using value/onChange pattern
- **Form validation** with proper error states
- **Accessibility** with proper labels and ARIA attributes
- **Multi-modal inputs** for rich user interactions

Example from [multimodal-input.tsx](mdc:components/multimodal-input.tsx):

```typescript
<Textarea
  ref={textareaRef}
  placeholder="Send a message..."
  value={input}
  onChange={handleInput}
  className="resize-none bg-transparent"
  rows={3}
  onKeyDown={submitOnEnter}
/>
```

### Form State Management

```typescript
// Complex form with validation
export function ChatForm({ onSubmit }: ChatFormProps) {
  const [input, setInput] = useState("");
  const [attachments, setAttachments] = useState<Attachment[]>([]);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = useCallback(
    async (e: FormEvent) => {
      e.preventDefault();
      if (!input.trim() || isSubmitting) return;

      setIsSubmitting(true);
      try {
        await onSubmit({ input, attachments });
        setInput("");
        setAttachments([]);
      } finally {
        setIsSubmitting(false);
      }
    },
    [input, attachments, isSubmitting, onSubmit]
  );

  return <form onSubmit={handleSubmit}>{/* Form elements */}</form>;
}
```

## Animation & Interactions

### Framer Motion Integration

- **Page transitions** with proper exit animations
- **Component animations** for enhanced UX
- **Gesture handling** for mobile interactions
- **Layout animations** for dynamic content

Example from [artifact.tsx](mdc:components/artifact.tsx):

```typescript
<AnimatePresence>
  {artifact.isVisible && (
    <motion.div
      data-testid="artifact"
      className="flex flex-row h-dvh w-dvw fixed top-0 left-0 z-50 bg-transparent"
      initial={{ opacity: 1 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0, transition: { delay: 0.4 } }}
    >
      {/* Content */}
    </motion.div>
  )}
</AnimatePresence>
```

### Responsive Animations

```typescript
// Responsive motion with window size
const { width: windowWidth } = useWindowSize();
const isMobile = windowWidth ? windowWidth < 768 : false;

<motion.div
  initial={{
    width: isSidebarOpen ? windowWidth - 256 : windowWidth,
    right: 0,
  }}
  animate={{ width: windowWidth, right: 0 }}
  exit={{
    width: isSidebarOpen ? windowWidth - 256 : windowWidth,
    right: 0,
  }}
/>;
```

## Component Communication Patterns

### Props Down, Events Up

```typescript
// Parent component
export function ChatContainer() {
  const [messages, setMessages] = useState<Message[]>([]);

  const handleNewMessage = useCallback((message: Message) => {
    setMessages((prev) => [...prev, message]);
  }, []);

  return (
    <div>
      <MessageList messages={messages} />
      <MessageInput onSubmit={handleNewMessage} />
    </div>
  );
}

// Child component
export function MessageInput({
  onSubmit,
}: {
  onSubmit: (msg: Message) => void;
}) {
  const handleSubmit = (text: string) => {
    onSubmit({
      id: generateUUID(),
      text,
      timestamp: new Date(),
    });
  };

  return <form onSubmit={handleSubmit}>{/* Input form */}</form>;
}
```

### Context for Deep Prop Drilling

```typescript
// Avoid deep prop drilling with context
const ModelContext = createContext<{
  selectedModelId: string;
  availableModels: ChatModel[];
  selectModel: (id: string) => void;
} | null>(null);

export function useModel() {
  const context = useContext(ModelContext);
  if (!context) {
    throw new Error("useModel must be used within ModelProvider");
  }
  return context;
}
```

## Performance Optimizations

### Rendering Optimizations

- **React.memo** for expensive components
- **useMemo/useCallback** for expensive computations
- **Dynamic imports** for code splitting
- **Image optimization** with Next.js Image component

```typescript
// Memoized component with custom comparison
export const MessageItem = memo(
  ({ message, onVote }: MessageItemProps) => {
    const handleVote = useCallback(
      (type: "up" | "down") => {
        onVote(message.id, type);
      },
      [message.id, onVote]
    );

    return (
      <div>
        <p>{message.text}</p>
        <VoteButtons onVote={handleVote} />
      </div>
    );
  },
  (prevProps, nextProps) => {
    // Custom comparison to prevent unnecessary re-renders
    return (
      prevProps.message.id === nextProps.message.id &&
      prevProps.message.text === nextProps.message.text
    );
  }
);
```

### Event Handling

- **Debounced inputs** for search and filter functionality
- **Throttled scroll handlers** for performance
- **Event delegation** when appropriate
- **Cleanup effects** in useEffect hooks

```typescript
// Debounced search input
export function SearchInput({ onSearch }: SearchInputProps) {
  const [query, setQuery] = useState("");
  const debouncedQuery = useDebounce(query, 300);

  useEffect(() => {
    if (debouncedQuery) {
      onSearch(debouncedQuery);
    }
  }, [debouncedQuery, onSearch]);

  return (
    <input
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      placeholder="Search..."
    />
  );
}
```

## Error Boundaries & Error Handling

### Component Error Boundaries

```typescript
interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

export class ComponentErrorBoundary extends Component<
  { children: ReactNode; fallback?: ComponentType<{ error: Error }> },
  ErrorBoundaryState
> {
  constructor(props: any) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Component error:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      const FallbackComponent = this.props.fallback || DefaultErrorFallback;
      return <FallbackComponent error={this.state.error!} />;
    }

    return this.props.children;
  }
}
```

### Graceful Error Handling

```typescript
// Component with error handling
export function DataComponent() {
  const { data, error, isLoading } = useSWR("/api/data", fetcher);
  const [retryCount, setRetryCount] = useState(0);

  const handleRetry = useCallback(() => {
    setRetryCount((prev) => prev + 1);
    mutate(); // Retry SWR request
  }, [mutate]);

  if (error) {
    return (
      <div className="p-4 border border-red-200 rounded">
        <p className="text-red-600">Failed to load data</p>
        <button
          onClick={handleRetry}
          className="mt-2 px-3 py-1 bg-red-100 rounded"
        >
          Retry ({retryCount > 0 && `${retryCount} attempts`})
        </button>
      </div>
    );
  }

  if (isLoading) {
    return <LoadingSkeleton />;
  }

  return <div>{/* Render data */}</div>;
}
```

## Accessibility Guidelines

### ARIA & Semantic HTML

- **Proper heading hierarchy** (h1, h2, h3, etc.)
- **ARIA labels** for interactive elements
- **Focus management** for modal and drawer components
- **Keyboard navigation** support

```typescript
// Accessible dropdown component
export function AccessibleDropdown({
  trigger,
  items,
  onSelect,
}: DropdownProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [activeIndex, setActiveIndex] = useState(-1);

  const handleKeyDown = useCallback(
    (e: KeyboardEvent) => {
      switch (e.key) {
        case "ArrowDown":
          e.preventDefault();
          setActiveIndex((prev) => (prev < items.length - 1 ? prev + 1 : 0));
          break;
        case "ArrowUp":
          e.preventDefault();
          setActiveIndex((prev) => (prev > 0 ? prev - 1 : items.length - 1));
          break;
        case "Enter":
          if (activeIndex >= 0) {
            onSelect(items[activeIndex]);
            setIsOpen(false);
          }
          break;
        case "Escape":
          setIsOpen(false);
          break;
      }
    },
    [activeIndex, items, onSelect]
  );

  return (
    <div className="relative">
      <button
        aria-expanded={isOpen}
        aria-haspopup="listbox"
        onClick={() => setIsOpen(!isOpen)}
      >
        {trigger}
      </button>

      {isOpen && (
        <ul
          role="listbox"
          className="absolute z-10 bg-white border rounded shadow"
          onKeyDown={handleKeyDown}
        >
          {items.map((item, index) => (
            <li
              key={item.id}
              role="option"
              aria-selected={index === activeIndex}
              className={cn(
                "px-3 py-2 cursor-pointer",
                index === activeIndex && "bg-blue-100"
              )}
              onClick={() => {
                onSelect(item);
                setIsOpen(false);
              }}
            >
              {item.label}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

### Screen Reader Support

- **Alt text** for images and icons
- **Live regions** for dynamic content updates
- **Skip links** for navigation
- **Color contrast** compliance

```typescript
// Live region for dynamic updates
export function MessageList({ messages }: MessageListProps) {
  const [announcement, setAnnouncement] = useState("");

  useEffect(() => {
    if (messages.length > 0) {
      const latestMessage = messages[messages.length - 1];
      if (latestMessage.role === "assistant") {
        setAnnouncement(
          `New response: ${latestMessage.content.slice(0, 100)}...`
        );
      }
    }
  }, [messages]);

  return (
    <div>
      {/* Screen reader announcement */}
      <div aria-live="polite" aria-atomic="true" className="sr-only">
        {announcement}
      </div>

      {/* Message list */}
      <div role="log" aria-label="Chat messages">
        {messages.map((message) => (
          <MessageItem key={message.id} message={message} />
        ))}
      </div>
    </div>
  );
}
```

## Testing Considerations

### Component Testing

- **Isolated component testing** with proper mocks
- **User interaction testing** with testing-library
- **Accessibility testing** with axe-core
- **Visual regression testing** when appropriate

```typescript
// Component test example
describe("MessageInput", () => {
  it("should call onSubmit when form is submitted", async () => {
    const mockOnSubmit = jest.fn();
    render(<MessageInput onSubmit={mockOnSubmit} />);

    const input = screen.getByRole("textbox");
    const submitButton = screen.getByRole("button", { name: /send/i });

    await user.type(input, "Hello world");
    await user.click(submitButton);

    expect(mockOnSubmit).toHaveBeenCalledWith({
      text: "Hello world",
      attachments: [],
    });
  });

  it("should be accessible", async () => {
    render(<MessageInput onSubmit={jest.fn()} />);
    const results = await axe(screen.getByRole("form"));
    expect(results).toHaveNoViolations();
  });
});
```

### Integration Testing

- **End-to-end testing** with Playwright (see [tests/](mdc:tests/) directory)
- **API integration testing** for data flows
- **Authentication flow testing**
- **Error boundary testing**

```typescript
// Integration test example
test("should handle chat flow", async () => {
  render(<ChatApplication />);

  // Navigate to chat
  await user.click(screen.getByRole("link", { name: /new chat/i }));

  // Send message
  const input = screen.getByRole("textbox");
  await user.type(input, "Hello AI");
  await user.click(screen.getByRole("button", { name: /send/i }));

  // Wait for response
  await waitFor(() => {
    expect(screen.getByText(/hello.*human/i)).toBeInTheDocument();
  });
});
```

## Component Composition Patterns

### Compound Components

```typescript
// Compound component pattern for complex UI
export function Dialog({ children, open, onOpenChange }: DialogProps) {
  return (
    <DialogPrimitive.Root open={open} onOpenChange={onOpenChange}>
      {children}
    </DialogPrimitive.Root>
  );
}

Dialog.Trigger = DialogPrimitive.Trigger;
Dialog.Content = DialogPrimitive.Content;
Dialog.Header = DialogHeader;
Dialog.Title = DialogPrimitive.Title;
Dialog.Description = DialogPrimitive.Description;

// Usage
<Dialog open={isOpen} onOpenChange={setIsOpen}>
  <Dialog.Trigger>Open Dialog</Dialog.Trigger>
  <Dialog.Content>
    <Dialog.Header>
      <Dialog.Title>Title</Dialog.Title>
      <Dialog.Description>Description</Dialog.Description>
    </Dialog.Header>
    {/* Content */}
  </Dialog.Content>
</Dialog>;
```

### Render Props Pattern

```typescript
// Render props for flexible rendering
export function DataFetcher<T>({
  url,
  children,
}: {
  url: string;
  children: (
    data: T | null,
    loading: boolean,
    error: Error | null
  ) => ReactNode;
}) {
  const { data, error, isLoading } = useSWR<T>(url, fetcher);

  return <>{children(data || null, isLoading, error)}</>;
}

// Usage
<DataFetcher<User> url="/api/user">
  {(user, loading, error) => {
    if (loading) return <Spinner />;
    if (error) return <ErrorMessage error={error} />;
    if (!user) return <div>No user found</div>;
    return <UserProfile user={user} />;
  }}
</DataFetcher>;
```
