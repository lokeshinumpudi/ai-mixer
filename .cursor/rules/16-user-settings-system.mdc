---
alwaysApply: true
description: User settings system patterns, database persistence, and cross-session preference management
---

# User Settings System

## Overview

The application implements a comprehensive user settings system that provides database-backed user preferences with optimistic updates, cross-session persistence, and seamless synchronization across all user devices and chat windows.

## Core Architecture

### Database Schema

User settings are stored in a dedicated `userSettings` table with a one-to-one relationship with users:

```typescript
// lib/db/schema.ts
export const userSettings = pgTable("UserSettings", {
  id: uuid("id").primaryKey().notNull().defaultRandom(),
  userId: uuid("userId")
    .notNull()
    .references(() => user.id)
    .unique(),
  settings: json("settings").notNull().default({}),
  updatedAt: timestamp("updatedAt").notNull().defaultNow(),
});

export type UserSettings = InferSelectModel<typeof userSettings>;
```

### Database Queries

All user settings operations are centralized in `lib/db/queries.ts`:

```typescript
// Get user settings
export async function getUserSettings(userId: string) {
  try {
    const [settings] = await db
      .select()
      .from(userSettings)
      .where(eq(userSettings.userId, userId))
      .limit(1);

    return settings;
  } catch (error) {
    throw new ChatSDKError(
      "bad_request:database",
      "Failed to get user settings"
    );
  }
}

// Create or update user settings
export async function upsertUserSettings(
  userId: string,
  settings: Record<string, any>
) {
  try {
    await db
      .insert(userSettings)
      .values({
        userId,
        settings,
        updatedAt: new Date(),
      })
      .onConflictDoUpdate({
        target: userSettings.userId,
        set: {
          settings,
          updatedAt: new Date(),
        },
      });

    return { success: true };
  } catch (error) {
    throw new ChatSDKError(
      "bad_request:database",
      "Failed to upsert user settings"
    );
  }
}

// Update individual setting
export async function updateUserSetting(
  userId: string,
  key: string,
  value: any
) {
  try {
    // Get current settings and merge with updates
    const currentSettings = await getUserSettings(userId);
    const updatedSettings = {
      ...(currentSettings?.settings || {}),
      [key]: value,
    };

    return await upsertUserSettings(userId, updatedSettings);
  } catch (error) {
    throw new ChatSDKError(
      "bad_request:database",
      "Failed to update user setting"
    );
  }
}
```

## Client-Side Hooks

### useUserSettings Hook

The main hook for managing user settings with optimistic updates:

```typescript
// hooks/use-user-settings.ts
export interface UserSettings {
  defaultModel?: string;
  theme?: "light" | "dark" | "system";
  sidebarCollapsed?: boolean;
  [key: string]: any;
}

export interface UseUserSettingsReturn {
  settings: UserSettings;
  updateSetting: (key: string, value: any) => Promise<void>;
  updateSettings: (newSettings: Partial<UserSettings>) => Promise<void>;
  isLoading: boolean;
  error: any;
}

export function useUserSettings(
  session: Session | null
): UseUserSettingsReturn {
  const userId = session?.user?.id;

  // Fetch settings from API with SWR
  const {
    data: settingsData,
    mutate: mutateSettings,
    isLoading,
    error,
  } = useSWR<UserSettings>(userId ? `/api/user/settings` : null, fetcher, {
    fallbackData: {},
    revalidateOnFocus: false,
    revalidateOnReconnect: true,
  });

  // Optimistic local state for immediate UI updates
  const [optimisticSettings, setOptimisticSettings] = useState<UserSettings>(
    {}
  );

  // Combine server data with optimistic updates
  const settings = { ...settingsData, ...optimisticSettings };

  // Update a single setting with optimistic update
  const updateSetting = useCallback(
    async (key: string, value: any) => {
      if (!userId) return;

      // Optimistic update
      setOptimisticSettings((prev) => ({ ...prev, [key]: value }));

      try {
        // Server update
        const response = await fetch("/api/user/settings", {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ [key]: value }),
        });

        if (!response.ok) {
          throw new Error("Failed to update setting");
        }

        // Update SWR cache
        await mutateSettings((current) => ({
          ...current,
          [key]: value,
        }));

        // Clear optimistic update
        setOptimisticSettings((prev) => {
          const next = { ...prev };
          delete next[key];
          return next;
        });
      } catch (error) {
        // Revert optimistic update on error
        setOptimisticSettings((prev) => {
          const next = { ...prev };
          delete next[key];
          return next;
        });
        throw error;
      }
    },
    [userId, mutateSettings]
  );

  // Update multiple settings at once
  const updateSettings = useCallback(
    async (newSettings: Partial<UserSettings>) => {
      if (!userId) return;

      // Optimistic update
      setOptimisticSettings((prev) => ({ ...prev, ...newSettings }));

      try {
        // Server update
        const response = await fetch("/api/user/settings", {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(newSettings),
        });

        if (!response.ok) {
          throw new Error("Failed to update settings");
        }

        // Update SWR cache
        await mutateSettings((current) => ({
          ...current,
          ...newSettings,
        }));

        // Clear optimistic updates
        setOptimisticSettings((prev) => {
          const next = { ...prev };
          Object.keys(newSettings).forEach((key) => {
            delete next[key];
          });
          return next;
        });
      } catch (error) {
        // Revert optimistic updates on error
        setOptimisticSettings((prev) => {
          const next = { ...prev };
          Object.keys(newSettings).forEach((key) => {
            delete next[key];
          });
          return next;
        });
        throw error;
      }
    },
    [userId, mutateSettings]
  );

  return {
    settings,
    updateSetting,
    updateSettings,
    isLoading,
    error,
  };
}
```

### Model Selection Integration

**⚠️ DEPRECATED**: The `useSelectedModel` hook is deprecated in favor of the integrated models API approach.

**✅ NEW APPROACH**: Use the consolidated `useModels` hook which includes user settings:

```typescript
// ✅ PREFERRED: Use integrated models API
export function Chat({ session, initialChatModel }: ChatProps) {
  const { userSettings, models } = useModels();

  // Get current model from settings with fallback chain
  const currentModel =
    userSettings?.defaultModel ||
    initialChatModel ||
    getDefaultModelForUser(session.user.type);

  // Model selection is handled via PATCH to /api/user/settings
  // and synchronized through the models API refresh
}
```

**❌ AVOID**: Separate API calls for model selection:

```typescript
// ❌ DEPRECATED: Don't use separate settings API for model selection
const { selectedModel } = useSelectedModel(session); // Creates redundant API calls
```

## API Routes

### Settings API Endpoints

```typescript
// app/(chat)/api/user/settings/route.ts

// GET - Fetch user settings
export const GET = protectedRoute(async (request, context, user) => {
  try {
    const settings = await getUserSettings(user.id);
    const settingsData = settings?.settings || {};

    return Response.json(settingsData, { status: 200 });
  } catch (error) {
    return new ChatSDKError(
      "bad_request:api",
      "Failed to get user settings"
    ).toResponse();
  }
});

// PUT - Replace all user settings
export const PUT = protectedRoute(async (request, context, user) => {
  try {
    const settingsUpdate = await request.json();

    if (typeof settingsUpdate !== "object" || settingsUpdate === null) {
      return new ChatSDKError(
        "bad_request:api",
        "Settings must be an object"
      ).toResponse();
    }

    await upsertUserSettings(user.id, settingsUpdate);

    return Response.json({ success: true }, { status: 200 });
  } catch (error) {
    return new ChatSDKError(
      "bad_request:api",
      "Failed to update user settings"
    ).toResponse();
  }
});

// PATCH - Update specific settings
export const PATCH = protectedRoute(async (request, context, user) => {
  try {
    const settingsUpdate = await request.json();

    if (typeof settingsUpdate !== "object" || settingsUpdate === null) {
      return new ChatSDKError(
        "bad_request:api",
        "Settings update must be an object"
      ).toResponse();
    }

    // Get current settings and merge with updates
    const currentSettings = await getUserSettings(user.id);
    const updatedSettings = {
      ...(currentSettings?.settings || {}),
      ...settingsUpdate,
    };

    await upsertUserSettings(user.id, updatedSettings);

    return Response.json({ success: true }, { status: 200 });
  } catch (error) {
    return new ChatSDKError(
      "bad_request:api",
      "Failed to update user settings"
    ).toResponse();
  }
});
```

## Component Integration

### Settings-Aware Components

All components that use user preferences should accept session props:

```typescript
// components/model-picker.tsx
interface ModelPickerProps {
  session?: Session | null;
  selectedModelId?: string;
  className?: string;
  compact?: boolean;
  disabled?: boolean;
}

export function ModelPicker({
  session,
  selectedModelId,
  className,
  compact = false,
  disabled = false,
}: ModelPickerProps) {
  // Use settings-based model selection
  const { selectedModel: settingsModel, setSelectedModel } =
    useSelectedModel(session);
  const { models: allModels, isLoading, userType } = useModels();

  // Get plan-based default model as fallback
  const planBasedDefaultModel = useMemo(() => {
    return getDefaultModelForUser(session.user.type);
  }, [session.user.type]);

  // Determine the effective model to use
  const effectiveModelId = useMemo(() => {
    // Props override for backward compatibility
    if (selectedModelId) {
      const modelExists = allModels.some(
        (model) => model.id === selectedModelId
      );
      if (modelExists) return selectedModelId;
    }

    // Settings-based model
    const modelExists = allModels.some((model) => model.id === settingsModel);
    return modelExists ? settingsModel : planBasedDefaultModel;
  }, [selectedModelId, settingsModel, allModels, planBasedDefaultModel]);

  const handleModelSelect = async (modelId: string) => {
    setOpen(false);
    try {
      await setSelectedModel(modelId);
    } catch (error) {
      console.error("Failed to save model selection:", error);
    }
  };

  // ... rest of component
}
```

## Best Practices

### 1. Settings Key Naming

Use consistent, descriptive keys for settings:

```typescript
// Good
const settings = {
  defaultModel: "openai/gpt-4o-mini",
  theme: "dark",
  sidebarCollapsed: false,
  notificationsEnabled: true,
};

// Avoid
const settings = {
  model: "openai/gpt-4o-mini", // Too generic
  t: "dark", // Too abbreviated
  collapsed: false, // Context unclear
};
```

### 2. Settings Validation

Validate settings on both client and server:

```typescript
// Client-side validation
const validThemes = ["light", "dark", "system"];
const themeSchema = z.enum(validThemes);

const updateTheme = async (newTheme: string) => {
  const validatedTheme = themeSchema.parse(newTheme);
  await updateSetting("theme", validatedTheme);
};

// Server-side validation in API routes
const settingsUpdate = await request.json();
const validatedSettings = settingsSchema.parse(settingsUpdate);
```

### 3. Optimistic Updates

Always use optimistic updates for better UX:

```typescript
const updateWithOptimism = async (key: string, value: any) => {
  // Update local state immediately
  setOptimisticSettings((prev) => ({ ...prev, [key]: value }));

  try {
    // Update server
    await updateSetting(key, value);

    // Update SWR cache
    mutateSettings((current) => ({
      ...current,
      [key]: value,
    }));

    // Clear optimistic update
    setOptimisticSettings((prev) => {
      const next = { ...prev };
      delete next[key];
      return next;
    });
  } catch (error) {
    // Revert optimistic update on error
    setOptimisticSettings((prev) => {
      const next = { ...prev };
      delete next[key];
      return next;
    });
    throw error;
  }
};
```

### 4. Settings Migration

Handle settings schema changes gracefully:

```typescript
// In API route or hook
const migrateSettings = (settings: any) => {
  const migrated = { ...settings };

  // Add new default settings
  if (migrated.theme === undefined) {
    migrated.theme = "system";
  }

  // Remove deprecated settings
  delete migrated.oldSetting;

  return migrated;
};
```

## Performance Considerations

### 1. SWR Configuration

Configure SWR for optimal settings loading:

```typescript
const { data: settingsData, mutate: mutateSettings } = useSWR<UserSettings>(
  userId ? `/api/user/settings` : null,
  fetcher,
  {
    fallbackData: {}, // Prevent loading states
    revalidateOnFocus: false, // Don't refetch on window focus
    revalidateOnReconnect: true, // Refetch on reconnect
    dedupingInterval: 5000, // Dedupe requests within 5 seconds
  }
);
```

### 2. Selective Updates

Update only the settings you need:

```typescript
// Good - Update specific setting
await updateSetting("theme", "dark");

// Avoid - Update entire settings object unnecessarily
const currentSettings = await getUserSettings(userId);
await upsertUserSettings(userId, {
  ...currentSettings?.settings,
  theme: "dark",
});
```

### 3. Batch Updates

Batch multiple setting updates:

```typescript
// Good - Batch related updates
await updateSettings({
  theme: "dark",
  sidebarCollapsed: true,
  notificationsEnabled: false,
});

// Avoid - Multiple individual requests
await updateSetting("theme", "dark");
await updateSetting("sidebarCollapsed", true);
await updateSetting("notificationsEnabled", false);
```

## Security Considerations

### 1. Input Validation

Always validate settings input:

```typescript
// Server-side validation
const settingsSchema = z.object({
  defaultModel: z.string().optional(),
  theme: z.enum(["light", "dark", "system"]).optional(),
  sidebarCollapsed: z.boolean().optional(),
});

export const PATCH = protectedRoute(async (request, context, user) => {
  const settingsUpdate = await request.json();
  const validatedSettings = settingsSchema.parse(settingsUpdate);

  // Continue with validated settings
});
```

### 2. User Isolation

Ensure settings are user-scoped:

```typescript
// Always filter by userId
const [settings] = await db
  .select()
  .from(userSettings)
  .where(eq(userSettings.userId, user.id)) // Critical for security
  .limit(1);
```

### 3. Sensitive Data

Never store sensitive information in settings:

```typescript
// Good - Store preference IDs
const settings = {
  defaultModel: "openai/gpt-4o-mini",
  theme: "dark",
};

// Avoid - Store sensitive data
const settings = {
  apiKey: "sk-1234567890", // Never do this!
  password: "secret", // Never do this!
};
```

## Testing

### 1. Hook Testing

Test user settings hooks with proper mocking:

```typescript
describe("useUserSettings", () => {
  it("should update setting optimistically", async () => {
    const mockSession = { user: { id: "user-123" } };
    const { result } = renderHook(() => useUserSettings(mockSession));

    act(() => {
      result.current.updateSetting("theme", "dark");
    });

    expect(result.current.settings.theme).toBe("dark");
  });

  it("should revert optimistic update on error", async () => {
    // Mock API to reject
    const mockSession = { user: { id: "user-123" } };
    const { result } = renderHook(() => useUserSettings(mockSession));

    await act(async () => {
      try {
        await result.current.updateSetting("theme", "invalid");
      } catch {}
    });

    expect(result.current.settings.theme).not.toBe("invalid");
  });
});
```

### 2. API Testing

Test settings API endpoints:

```typescript
describe("GET /api/user/settings", () => {
  it("should return user settings", async () => {
    const response = await app.request("/api/user/settings", {
      headers: { Authorization: "Bearer valid-token" },
    });

    expect(response.status).toBe(200);
    const settings = await response.json();
    expect(settings).toHaveProperty("defaultModel");
  });

  it("should require authentication", async () => {
    const response = await app.request("/api/user/settings");

    expect(response.status).toBe(401);
  });
});
```

### 3. Integration Testing

Test end-to-end settings flow:

```typescript
test("should persist model selection across sessions", async () => {
  // User selects model
  await user.click(screen.getByText("GPT-4"));
  await user.click(screen.getByText("Select Model"));

  // Mock page reload
  // Settings should persist
  expect(screen.getByText("GPT-4")).toBeInTheDocument();
});
```

## Migration Guide

### From Cookie-Based to Database Settings

1. **Create userSettings table migration**
2. **Update components to use useSelectedModel hook**
3. **Remove cookie-based logic**
4. **Add optimistic updates for better UX**
5. **Test cross-session persistence**

### Backward Compatibility

Maintain backward compatibility during migration:

```typescript
// Support both props-based and settings-based model selection
const effectiveModelId = useMemo(() => {
  // Props override for backward compatibility
  if (selectedModelId) {
    const modelExists = allModels.some((model) => model.id === selectedModelId);
    if (modelExists) return selectedModelId;
  }

  // Settings-based model
  const modelExists = allModels.some((model) => model.id === settingsModel);
  return modelExists ? settingsModel : planBasedDefaultModel;
}, [selectedModelId, settingsModel, allModels, planBasedDefaultModel]);
```

This comprehensive user settings system ensures consistent, secure, and performant user preferences across the entire application with excellent developer and user experience.
