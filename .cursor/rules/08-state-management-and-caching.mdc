---
alwaysApply: true
description: "SWR usage, local state, and offline-first caching strategies."
---

# 08: State Management & Caching

## Core Principles

- **SWR for Server State**: Use SWR for fetching, caching, and revalidating all server-side data.
- **React Hooks for Local State**: Use `useState`, `useReducer`, and `useRef` for component-level state.
- **Offline-First**: Prioritize loading data from a local cache (localStorage) for an instant user experience, with background synchronization to fetch fresh data.

## SWR & Caching Strategy

The application employs a cache-first strategy. Components should first attempt to load data from a local cache and then trigger a background revalidation with the server.

```typescript
// hooks/use-chat-messages.ts
export function useChatMessages(chatId: string) {
  const cacheKey = `chat-messages-${chatId}`;
  const [cachedMessages] = useState(() => safeReadFromCache(cacheKey));

  const { data: messages, mutate } = useSWR(
    `/api/chat/${chatId}/messages`,
    fetcher,
    {
      fallbackData: cachedMessages, // Load from cache instantly
      revalidateOnMount: true, // Revalidate in the background
      onSuccess: (data) => {
        if (data) safeWriteToCache(cacheKey, data); // Update cache
      },
    }
  );

  return { messages: messages || cachedMessages || [], mutate };
}
```

## State Management Layers

- **Local State**: For UI state like form inputs or dialog visibility.
- **Server State (SWR)**: For data fetched from the API. SWR handles caching, revalidation, and optimistic updates.
- **Chat-Scoped State**: For features like the artifacts system, state is scoped to a specific `chatId` to prevent state leakage between conversations.
- **Global State (Context)**: For cross-cutting concerns like data streaming (`DataStreamProvider`) and theme management.

## Optimistic Updates

For actions like voting or updating settings, use optimistic updates to provide immediate UI feedback.

1.  Update the local SWR cache immediately with the expected new state.
2.  Send the update request to the server.
3.  If the server request fails, SWR automatically rolls back the change.
4.  If it succeeds, revalidate the data to ensure consistency.
