---
alwaysApply: true
description: Quick reference and best practices overview for the AI chatbot playground
---

# AI Chatbot Playground - Quick Reference

## 🏗️ Architecture Overview

This is a **Next.js 15 AI chatbot application** with real-time streaming, artifacts generation, and multi-modal interactions.

### Tech Stack

- **Frontend**: Next.js 15, React Client Components, shadcn/ui, Tailwind CSS
- **AI**: AI SDK v5 with Gateway, multi-provider support, tool calling, streaming
- **Backend**: Drizzle ORM, PostgreSQL, Auth.js v5, Razorpay payments
- **Offline-First**: Cache-first data loading with localStorage persistence
- **User Settings**: Database-backed user preferences with cross-session persistence
- **Artifacts**: Text, Code, Image, Sheet generation with chat-scoped state management

### Key Directories

```
app/            # Next.js App Router with client-side, offline-first routes
├── (auth)/     # Authentication routes
└── (chat)/     # Client-rendered chat interface with cache-first data
components/     # UI components (shadcn/ui + custom) with settings integration
lib/            # Core application logic
├── ai/         # AI SDK integration and tools
├── db/         # Database schema, queries, and user settings management
└── artifacts/  # Artifact system logic
artifacts/      # Artifact type implementations
hooks/          # Custom React hooks for settings, cache, and offline-first patterns
```

## 🔥 Quick Patterns

### Adding a New Component

```typescript
"use client"; // Client components for interactive features

interface ComponentProps {
  // Clear prop types
  session?: Session | null; // Include session for settings-aware components
}

export function Component({ prop, session }: ComponentProps) {
  // Hooks first - include settings hooks for user preferences
  // Event handlers
  // Render logic
  return <div className="semantic-tailwind-classes">{/* content */}</div>;
}
```

### Creating an AI Tool

```typescript
// lib/ai/tools/my-tool.ts
export const myTool = ({ session, dataStream }: ToolProps) =>
  tool({
    description: "Clear tool description",
    inputSchema: z.object({
      param: z.string(),
    }),
    execute: async ({ param }) => {
      // Stream updates for real-time UX
      dataStream.write({
        type: "data-update",
        data: "Processing...",
        transient: true,
      });

      return { result: "Tool result" };
    },
  });
```

### User Settings Management

```typescript
// lib/db/queries.ts - User settings patterns
export async function getUserSettings(userId: string) {
  try {
    const [settings] = await db
      .select()
      .from(userSettings)
      .where(eq(userSettings.userId, userId))
      .limit(1);

    return settings;
  } catch (error) {
    throw new ChatSDKError(
      "bad_request:database",
      "Failed to get user settings"
    );
  }
}

// hooks/use-user-settings.ts - Client-side settings management
export function useSelectedModel(session: Session | null): {
  selectedModel: string;
  setSelectedModel: (modelId: string) => Promise<void>;
  isLoading: boolean;
} {
  const { settings, updateSetting } = useUserSettings(session);

  const selectedModel =
    settings?.defaultModel ||
    getDefaultModelForUser(session?.user?.type as UserType);

  const setSelectedModel = useCallback(
    async (modelId: string) => {
      await updateSetting("defaultModel", modelId);
    },
    [updateSetting]
  );

  return { selectedModel, setSelectedModel, isLoading };
}
```

### Database Query Pattern

```typescript
// lib/db/queries.ts - ALL queries must be here
export async function getUserUsageAndLimits({
  userId,
  userType,
}: {
  userId: string;
  userType: UserType;
}) {
  try {
    const entitlements = entitlementsByUserType[userType];
    // Query logic with proper error handling
    return { used, quota, remaining, isOverLimit, type, resetInfo };
  } catch (error) {
    throw new ChatSDKError("bad_request:database", "Failed to get usage");
  }
}
```

### Custom Hook Pattern

```typescript
// hooks/use-usage.ts - Real-time usage tracking
export function useUsage() {
  const { data, mutate } = useSWR("/api/usage/summary", fetcher, {
    refreshInterval: 30000, // 30 seconds
  });

  const updateUsage = useCallback((newUsage: UsageInfo) => {
    setCurrentUsage(newUsage);
  }, []);

  return { usage: data?.plan, updateUsage };
}
```

## 🎯 Best Practices

### Code Quality

- ✅ **TypeScript strict mode** - Full type safety
- ✅ **Zod validation** - Runtime type checking
- ✅ **Error boundaries** - Graceful error handling
- ✅ **Client Components** - Default for interactive features with offline-first patterns
- ✅ **Path aliases (@/)** - Clean imports
- ✅ **User Settings** - Database-backed preferences with optimistic updates

### Performance

- ✅ **React.memo** - Prevent unnecessary re-renders
- ✅ **Debounced inputs** - Optimize user interactions
- ✅ **Dynamic imports** - Code splitting for large components
- ✅ **SWR caching** - Cache-first data loading with localStorage persistence
- ✅ **Image optimization** - Next.js Image component
- ✅ **Optimistic updates** - Instant UI feedback with server sync

### Security

- ✅ **Input validation** - Zod schemas for all inputs
- ✅ **Authentication** - Protected routes with database verification
- ✅ **Rate limiting** - Message limits based on user tier (free/pro)
- ✅ **Model access control** - Server-side entitlement validation
- ✅ **SQL injection prevention** - Parameterized queries with Drizzle
- ✅ **Settings persistence** - Secure user preferences in database

### UX/UI

- ✅ **Loading states** - Skeleton components and spinners
- ✅ **Error states** - Clear error messages with recovery options
- ✅ **Responsive design** - Mobile-first Tailwind approach
- ✅ **Accessibility** - ARIA labels, keyboard navigation
- ✅ **Dark mode** - Theme support throughout
- ✅ **Offline-first** - Cache-first data loading with sync indicators

## 🚀 Development Workflow

### Getting Started

```bash
# Development
pnpm dev

# Database operations
pnpm db:migrate        # Run migrations
pnpm db:studio        # Open Drizzle Studio
pnpm db:generate      # Generate new migration

# Code quality
pnpm lint             # ESLint + Biome
pnpm format           # Format with Biome
pnpm test             # Playwright e2e tests
```

### File Creation Checklist

- [ ] **TypeScript interfaces** defined
- [ ] **Zod schemas** for validation
- [ ] **Error handling** implemented
- [ ] **Loading states** included
- [ ] **Accessibility** considered
- [ ] **Tests written** (where applicable)

### Common Patterns to Follow

- **Route groups** for organization: `(auth)` and `(chat)`
- **Client Components** with `'use client'` for interactive features
- **Custom hooks** for settings, cache, and offline-first patterns
- **SWR mutations** for optimistic updates with rollback
- **Cache-first data loading** with localStorage persistence
- **Stream data** for real-time updates
- **User settings** database-backed preferences management

## 📚 Related Files

### Core Configuration

- [package.json](mdc:package.json) - Dependencies and scripts
- [next.config.ts](mdc:next.config.ts) - Next.js configuration
- [tailwind.config.ts](mdc:tailwind.config.ts) - Tailwind setup
- [drizzle.config.ts](mdc:drizzle.config.ts) - Database configuration

### Key Implementation Files

- [app/layout.tsx](mdc:app/layout.tsx) - Root layout with providers
- [components/chat.tsx](mdc:components/chat.tsx) - Main chat interface with settings integration
- [lib/constants.ts](mdc:lib/constants.ts) - Unified model configuration and pricing
- [lib/db/schema.ts](mdc:lib/db/schema.ts) - Database schema with user settings
- [components/model-picker.tsx](mdc:components/model-picker.tsx) - Settings-aware model selection
- [hooks/use-user-settings.ts](mdc:hooks/use-user-settings.ts) - User preferences management
- [hooks/use-models.ts](mdc:hooks/use-models.ts) - Cache-first model loading
- [lib/db/queries.ts](mdc:lib/db/queries.ts) - Database queries including user settings

## 🎨 UI Standards

### Component Hierarchy

1. **Layout components** - Page structure and navigation
2. **Feature components** - Chat, artifacts, authentication
3. **UI components** - Reusable shadcn/ui components
4. **Utility components** - Helpers and wrappers

### Styling Guidelines

- **Tailwind classes** - Semantic utility-first approach
- **CSS variables** - Theme consistency
- **Component variants** - Using class-variance-authority
- **Responsive design** - Mobile-first breakpoints

### State Management

- **Local state** - useState for component state
- **Server state** - SWR for API data with real-time updates
- **Chat-scoped state** - Artifacts isolated per chat session
- **Usage tracking** - Real-time message limits and billing
- **Global state** - Context providers (DataStream, Theme, Usage)

---

> 💡 **Tip**: When in doubt, look at existing implementations in the codebase for patterns and conventions. The application follows consistent patterns throughout all modules. For settings-aware components, always include session props and use the user settings hooks. For data loading, prefer cache-first patterns with SWR for optimal offline-first performance.
