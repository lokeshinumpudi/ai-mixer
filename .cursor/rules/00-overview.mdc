---
alwaysApply: true
description: Quick reference and best practices overview for the AI chatbot playground
---

# AI Chatbot Playground - Quick Reference

## 🏗️ Architecture Overview

This is a **Next.js 15 AI chatbot application** with real-time streaming, artifacts generation, and multi-modal interactions.

### Tech Stack

- **Frontend**: Next.js 15, React Server Components, shadcn/ui, Tailwind CSS
- **AI**: AI SDK v5 with Gateway, multi-provider support, tool calling, streaming
- **Backend**: Drizzle ORM, PostgreSQL, Auth.js v5, Razorpay payments
- **Artifacts**: Text, Code, Image, Sheet generation with chat-scoped state management

### Key Directories

```
app/            # Next.js App Router with route groups
├── (auth)/     # Authentication routes
└── (chat)/     # Chat interface
components/     # UI components (shadcn/ui + custom)
lib/            # Core application logic
├── ai/         # AI SDK integration and tools
├── db/         # Database schema and queries
└── artifacts/  # Artifact system logic
artifacts/      # Artifact type implementations
hooks/          # Custom React hooks
```

## 🔥 Quick Patterns

### Adding a New Component

```typescript
"use client"; // Only if interactive

interface ComponentProps {
  // Clear prop types
}

export function Component({ prop }: ComponentProps) {
  // Hooks first
  // Event handlers
  // Render logic
  return <div className="semantic-tailwind-classes">{/* content */}</div>;
}
```

### Creating an AI Tool

```typescript
// lib/ai/tools/my-tool.ts
export const myTool = ({ session, dataStream }: ToolProps) =>
  tool({
    description: "Clear tool description",
    inputSchema: z.object({
      param: z.string(),
    }),
    execute: async ({ param }) => {
      // Stream updates
      dataStream.write({
        type: "data-update",
        data: "Processing...",
        transient: true,
      });

      return { result: "Tool result" };
    },
  });
```

### Database Query Pattern

```typescript
// lib/db/queries.ts - ALL queries must be here
export async function getUserUsageAndLimits({
  userId,
  userType,
}: {
  userId: string;
  userType: UserType;
}) {
  try {
    const entitlements = entitlementsByUserType[userType];
    // Query logic with proper error handling
    return { used, quota, remaining, isOverLimit, type, resetInfo };
  } catch (error) {
    throw new ChatSDKError("bad_request:database", "Failed to get usage");
  }
}
```

### Custom Hook Pattern

```typescript
// hooks/use-usage.ts - Real-time usage tracking
export function useUsage() {
  const { data, mutate } = useSWR("/api/usage/summary", fetcher, {
    refreshInterval: 30000, // 30 seconds
  });

  const updateUsage = useCallback((newUsage: UsageInfo) => {
    setCurrentUsage(newUsage);
  }, []);

  return { usage: data?.plan, updateUsage };
}
```

## 🎯 Best Practices

### Code Quality

- ✅ **TypeScript strict mode** - Full type safety
- ✅ **Zod validation** - Runtime type checking
- ✅ **Error boundaries** - Graceful error handling
- ✅ **Server Components** - Default to server-side rendering
- ✅ **Path aliases (@/)** - Clean imports

### Performance

- ✅ **React.memo** - Prevent unnecessary re-renders
- ✅ **Debounced inputs** - Optimize user interactions
- ✅ **Dynamic imports** - Code splitting for large components
- ✅ **SWR caching** - Efficient data fetching
- ✅ **Image optimization** - Next.js Image component

### Security

- ✅ **Input validation** - Zod schemas for all inputs
- ✅ **Authentication** - Protected routes with database verification
- ✅ **Rate limiting** - Message limits based on user tier (free/pro)
- ✅ **Model access control** - Server-side entitlement validation
- ✅ **SQL injection prevention** - Parameterized queries with Drizzle

### UX/UI

- ✅ **Loading states** - Skeleton components and spinners
- ✅ **Error states** - Clear error messages with recovery options
- ✅ **Responsive design** - Mobile-first Tailwind approach
- ✅ **Accessibility** - ARIA labels, keyboard navigation
- ✅ **Dark mode** - Theme support throughout

## 🚀 Development Workflow

### Getting Started

```bash
# Development
pnpm dev

# Database operations
pnpm db:migrate        # Run migrations
pnpm db:studio        # Open Drizzle Studio
pnpm db:generate      # Generate new migration

# Code quality
pnpm lint             # ESLint + Biome
pnpm format           # Format with Biome
pnpm test             # Playwright e2e tests
```

### File Creation Checklist

- [ ] **TypeScript interfaces** defined
- [ ] **Zod schemas** for validation
- [ ] **Error handling** implemented
- [ ] **Loading states** included
- [ ] **Accessibility** considered
- [ ] **Tests written** (where applicable)

### Common Patterns to Follow

- **Route groups** for organization: `(auth)` and `(chat)`
- **Server Actions** in `actions.ts` files
- **Custom hooks** for reusable logic
- **SWR mutations** for optimistic updates
- **Stream data** for real-time updates

## 📚 Related Files

### Core Configuration

- [package.json](mdc:package.json) - Dependencies and scripts
- [next.config.ts](mdc:next.config.ts) - Next.js configuration
- [tailwind.config.ts](mdc:tailwind.config.ts) - Tailwind setup
- [drizzle.config.ts](mdc:drizzle.config.ts) - Database configuration

### Key Implementation Files

- [app/layout.tsx](mdc:app/layout.tsx) - Root layout with providers
- [components/chat.tsx](mdc:components/chat.tsx) - Main chat interface
- [lib/constants.ts](mdc:lib/constants.ts) - Unified model configuration and pricing
- [lib/db/schema.ts](mdc:lib/db/schema.ts) - Database schema with usage tracking
- [components/model-picker.tsx](mdc:components/model-picker.tsx) - Enhanced model selection
- [hooks/use-usage.ts](mdc:hooks/use-usage.ts) - Real-time usage tracking

## 🎨 UI Standards

### Component Hierarchy

1. **Layout components** - Page structure and navigation
2. **Feature components** - Chat, artifacts, authentication
3. **UI components** - Reusable shadcn/ui components
4. **Utility components** - Helpers and wrappers

### Styling Guidelines

- **Tailwind classes** - Semantic utility-first approach
- **CSS variables** - Theme consistency
- **Component variants** - Using class-variance-authority
- **Responsive design** - Mobile-first breakpoints

### State Management

- **Local state** - useState for component state
- **Server state** - SWR for API data with real-time updates
- **Chat-scoped state** - Artifacts isolated per chat session
- **Usage tracking** - Real-time message limits and billing
- **Global state** - Context providers (DataStream, Theme, Usage)

---

> 💡 **Tip**: When in doubt, look at existing implementations in the codebase for patterns and conventions. The application follows consistent patterns throughout all modules.
