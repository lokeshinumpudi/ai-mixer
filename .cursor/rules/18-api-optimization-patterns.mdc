---
alwaysApply: true
description: API optimization patterns for reducing redundant calls and improving performance
---

# API Optimization and Data Consolidation Patterns

## Core Principle: Minimize API Calls Through Data Consolidation

### ✅ Preferred Pattern: Consolidated API Responses

Instead of making multiple API calls for related data, consolidate them into single endpoints:

```typescript
// ❌ AVOID: Multiple separate API calls
const { data: models } = useSWR("/api/models", fetcher);
const { data: userSettings } = useSWR("/api/user/settings", fetcher);

// ✅ PREFER: Consolidated API response
const { models, userSettings, userType } = useModels(); // Single API call to /api/models
```

### API Response Consolidation in [app/(chat)/api/models/route.ts](<mdc:app/(chat)/api/models/route.ts>)

```typescript
export const GET = protectedRoute(async (request, context, user) => {
  // Fetch related data in parallel
  const [userSettings, allModels] = await Promise.all([
    getUserSettings(user.id),
    gateway.getAvailableModels(),
  ]);

  return NextResponse.json({
    models: supportedModels,
    userType: user.type,
    userSettings: userSettings?.settings || {}, // Include user settings
  });
});
```

## Model Selection Architecture

### Hierarchical Model Selection Priority

Model selection follows a strict priority hierarchy to ensure consistency:

```typescript
// Priority order (highest to lowest):
// 1. Props selectedModelId (backward compatibility)
// 2. Server settings model (authoritative)
// 3. localStorage model (immediate persistence)
// 4. Plan-based default (ultimate fallback)

const effectiveModelId = useMemo(() => {
  if (selectedModelId && modelExists(selectedModelId)) return selectedModelId;
  if (serverModel && modelExists(serverModel)) return serverModel;
  if (localModel && modelExists(localModel)) return localModel;
  return planBasedDefaultModel;
}, [
  selectedModelId,
  serverModel,
  localModel,
  allModels,
  planBasedDefaultModel,
]);
```

### Component Integration Patterns

#### ✅ Components Using Models Should Use Consolidated API

```typescript
// ✅ CORRECT: Use integrated models API
import { useModels } from "@/hooks/use-models";

export function Chat({ session, initialChatModel }: ChatProps) {
  const { userSettings, models } = useModels();

  const currentModel =
    userSettings?.defaultModel ||
    initialChatModel ||
    getDefaultModelForUser(session.user.type);
}
```

#### ❌ Avoid Separate Settings API Calls

```typescript
// ❌ AVOID: Separate API call for user settings
import { useSelectedModel } from "@/hooks/use-user-settings";

export function Chat({ session }: ChatProps) {
  const { selectedModel } = useSelectedModel(session); // Separate API call
}
```

## Caching Strategy

### SWR Configuration for Consolidated APIs

```typescript
// Models API (includes user settings)
const { data } = useSWR("/api/models", fetcher, {
  revalidateOnMount: true,
  revalidateIfStale: false,
  revalidateOnFocus: false,
  refreshInterval: 15 * 60 * 1000, // 15 minutes
  dedupingInterval: 60 * 60 * 1000, // 1 hour
});

// User settings API (now secondary, less aggressive caching)
const { data } = useSWR("/api/user/settings", fetcher, {
  revalidateIfStale: false,
  revalidateOnFocus: false,
  revalidateOnReconnect: false,
  dedupingInterval: 30 * 1000, // 30 seconds only
});
```

## localStorage Integration for Offline-First

### Safe localStorage Utilities

```typescript
const safeLocalStorage = {
  get: (key: string): any => {
    try {
      if (typeof window === "undefined") return null;
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : null;
    } catch (error) {
      console.warn(`Failed to read from localStorage: ${key}`, error);
      return null;
    }
  },
  set: (key: string, value: any): void => {
    try {
      if (typeof window === "undefined") return;
      localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.warn(`Failed to write to localStorage: ${key}`, error);
    }
  },
};
```

### Server ↔ localStorage Synchronization

```typescript
// Sync localStorage with server when server data arrives
useEffect(() => {
  if (serverModel && serverModel !== localModel) {
    setLocalModel(serverModel);
    safeLocalStorage.set(MODEL_SELECTION_KEY, serverModel);
  }
}, [serverModel, localModel]);
```

## Performance Benefits

### Before Optimization (Multiple API Calls)

- 2+ separate API calls per page load
- Inconsistent state between components
- Race conditions between API responses
- Higher latency and bandwidth usage

### After Optimization (Consolidated APIs)

- 1 consolidated API call per page load
- Single source of truth for related data
- Consistent state across all components
- ~50% reduction in API calls

## Migration Checklist

When consolidating APIs:

- [ ] Identify related data that can be fetched together
- [ ] Update API endpoint to include consolidated data
- [ ] Create/update hooks to use consolidated API
- [ ] Update components to use new hook patterns
- [ ] Remove old separate API hooks where no longer needed
- [ ] Test hierarchical data selection logic
- [ ] Verify localStorage synchronization
- [ ] Update caching strategies appropriately

## Anti-Patterns to Avoid

### ❌ Don't Create Circular Dependencies

```typescript
// ❌ BAD: Hook A depends on Hook B, Hook B depends on Hook A
const useModelSelection = () => {
  const { settings } = useUserSettings(); // Calls /api/user/settings
  return settings.defaultModel;
};

const useUserSettings = () => {
  const { selectedModel } = useModelSelection(); // Creates circular dependency
  return { settings: { defaultModel: selectedModel } };
};
```

### ❌ Don't Over-Consolidate Unrelated Data

```typescript
// ❌ BAD: Mixing unrelated concerns in single API
return NextResponse.json({
  models: supportedModels,
  userSettings: userSettings,
  weatherData: weatherInfo, // Unrelated!
  stockPrices: stockData, // Unrelated!
  newsArticles: newsData, // Unrelated!
});
```

### ✅ Do Group Logically Related Data

```typescript
// ✅ GOOD: Related user context data
return NextResponse.json({
  models: supportedModels, // User needs models
  userSettings: userSettings, // User settings affect model selection
  userType: user.type, // User type affects model availability
  // All related to user's model selection context
});
```

This consolidation approach reduces API calls, improves consistency, and provides better user experience through faster load times and synchronized state.
