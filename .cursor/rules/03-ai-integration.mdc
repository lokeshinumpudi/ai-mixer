---
description: AI SDK Gateway integration patterns, unified model configuration, and dynamic capabilities system
---

# AI SDK Gateway Integration Architecture

## Overview

The application uses **AI SDK v5 with Gateway architecture** for a unified, scalable AI integration. This replaces custom provider abstractions with direct gateway usage while maintaining dynamic model management and capability-based features.

## Core Architecture

### 1. AI SDK Gateway Configuration

```typescript
// Reference: lib/gateway.ts - Simple gateway provider
import { createGatewayProvider } from "@ai-sdk/gateway";

export const gateway = createGatewayProvider({});
```

### 2. Unified Model Configuration

```typescript
// Reference: lib/constants.ts - Single source of truth
export const SUPPORTED_MODELS = {
  "xai/grok-3": {
    supportsReasoning: true,
    supportsArtifacts: true,
  },
  "xai/grok-3-mini": {
    supportsReasoning: true,
    supportsArtifacts: true,
  },
  "openai/gpt-4o-mini": {
    supportsReasoning: false,
    supportsArtifacts: true,
  },
  // ... more models
} as const;

// Derived constants for convenience
export const SUPPORTED_MODEL_IDS = Object.keys(SUPPORTED_MODELS);
export const DEFAULT_MODEL = "xai/grok-3-mini";
export const DEFAULT_IMAGE_MODEL = "xai/grok-2-image-1212";
```

### 3. Gateway Model Access

```typescript
// Reference: lib/ai/providers.ts - Direct gateway usage
import { gateway } from "@/lib/gateway";
import { getModelCapabilities } from "@/lib/constants";

export const getLanguageModel = (modelId: string) => {
  if (isTestEnvironment) {
    return chatModel; // Test model
  }

  const capabilities = getModelCapabilities(modelId);
  const baseModel = gateway.languageModel(modelId);

  // Apply reasoning middleware if supported
  if (capabilities?.supportsReasoning) {
    return wrapLanguageModel({
      model: baseModel,
      middleware: extractReasoningMiddleware({ tagName: "thinking" }),
    });
  }

  return baseModel;
};

export const modelSupports = (
  modelId: string,
  feature: "reasoning" | "artifacts"
): boolean => {
  const capabilities = getModelCapabilities(modelId);
  return feature === "reasoning"
    ? capabilities.supportsReasoning
    : capabilities.supportsArtifacts;
};
```

## API Integration Patterns

### 1. Dynamic Models API

```typescript
// Reference: app/(chat)/api/models/route.ts - Server-side filtering
export const GET = withSecurity(async (securityContext) => {
  const allModels = await gateway.getAvailableModels();
  const allowedModelIds = getAllowedModelIdsForUser(securityContext.user.type);

  const supportedModels = allModels.models
    .filter((model) => SUPPORTED_MODEL_IDS.includes(model.id))
    .map((model) => ({
      ...enrichModelWithCapabilities(model),
      enabled: allowedModelIds.includes(model.id), // Server-side entitlement
    }));

  return NextResponse.json({
    models: supportedModels,
    userType: securityContext.user.type,
  });
});
```

### 2. Enhanced Chat API

```typescript
// Reference: app/(chat)/api/chat/route.ts - Gateway integration
export async function POST(request: Request) {
  const { selectedChatModel } = await request.json();
  const session = await auth();

  // Validate model access with security logging
  const allowedModelIds = getAllowedModelIdsForUser(session.user.type);
  validateModelAccess(
    selectedChatModel,
    session.user.type,
    session.user.id,
    allowedModelIds
  );

  // Get model with dynamic capabilities
  const model = getLanguageModel(selectedChatModel);
  const supportsArtifacts = modelSupports(selectedChatModel, "artifacts");
  const supportsReasoning = modelSupports(selectedChatModel, "reasoning");

  const result = await streamText({
    model,
    system: systemPrompt({
      selectedModel: {
        id: selectedChatModel,
        supportsArtifacts,
        supportsReasoning,
      },
      requestHints,
    }),
    experimental_activeTools: supportsArtifacts
      ? ["getWeather", "createDocument", "updateDocument", "requestSuggestions"]
      : ["getWeather"],
    tools: {
      getWeather,
      createDocument: createDocument({ session, dataStream, selectedModel }),
      updateDocument: updateDocument({ session, dataStream, selectedModel }),
      requestSuggestions: requestSuggestions({
        session,
        dataStream,
        selectedModel,
      }),
    },
  });

  return result.toUIMessageStream({
    sendReasoning: supportsReasoning,
  });
}
```

### 3. Security-Enhanced API Routes

```typescript
// Reference: lib/security.ts - Comprehensive security middleware
export const withSecurity = (
  handler: (securityContext: SecurityContext) => Promise<Response>,
  options?: {
    requireAuth?: boolean;
    rateLimit?: boolean;
    maxRequestSize?: number;
  }
) => {
  return async (request: Request): Promise<Response> => {
    try {
      validateRequestSize(request, options?.maxRequestSize);
      const securityContext = await requireAuth(); // DB verification included

      if (options?.rateLimit && !checkRateLimit(securityContext.user.id)) {
        throw new ChatSDKError("rate_limit:api");
      }

      return await handler(securityContext);
    } catch (error) {
      return error instanceof ChatSDKError
        ? error.toResponse()
        : new ChatSDKError("bad_request:api").toResponse();
    }
  };
};
```

## Client-Side Integration

### 1. Dynamic Model Fetching

```typescript
// Reference: hooks/use-models.ts - Server-side filtering
export function useModels() {
  const { data, error, isLoading } = useSWR<ModelsResponse>(
    "/api/models",
    fetcher,
    {
      revalidateOnFocus: false,
      refreshInterval: 5 * 60 * 1000, // 5 minutes
    }
  );

  return {
    models: data?.models ?? [],
    userType: data?.userType ?? "guest",
    isLoading,
    error,
  };
}

export function isModelEnabled(model: ChatModel): boolean {
  return model.enabled !== false;
}
```

### 2. Enhanced Model Selector

```typescript
// Reference: components/model-selector.tsx - Server-filtered models
export function ModelSelector({
  session,
  selectedModelId,
}: ModelSelectorProps) {
  const { models: allModels, isLoading } = useModels();

  return (
    <DropdownMenuContent>
      {allModels.map((chatModel) => {
        const enabled = isModelEnabled(chatModel);

        return (
          <DropdownMenuItem
            key={chatModel.id}
            disabled={!enabled}
            onSelect={() => {
              if (!enabled) return; // Prevent disabled model selection
              saveChatModelAsCookie(chatModel.id);
            }}
          >
            <div className="flex items-center gap-2">
              {chatModel.name}
              {!enabled && (
                <span className="text-xs px-1.5 py-0.5 bg-muted rounded">
                  Pro
                </span>
              )}
            </div>
            <div className="text-xs text-muted-foreground">
              {chatModel.description}
            </div>
          </DropdownMenuItem>
        );
      })}
    </DropdownMenuContent>
  );
}
```

## Server Actions & Artifact Integration

### 1. Gateway-Based Server Actions

```typescript
// Reference: app/(chat)/actions.ts - No hardcoded models
export async function generateTitleFromUserMessage({
  message,
}: {
  message: UIMessage;
}) {
  const { text: title } = await generateText({
    model: getLanguageModel(DEFAULT_MODEL), // Dynamic model
    system: `Generate a short title based on the first message...`,
    prompt: JSON.stringify(message),
  });

  return title;
}
```

### 2. Artifact Handlers

```typescript
// Reference: artifacts/text/server.ts - Gateway integration
export const textDocumentHandler = createDocumentHandler<"text">({
  kind: "text",
  onCreateDocument: async ({ title, dataStream, selectedModel }) => {
    const { fullStream } = streamText({
      model: getLanguageModel(selectedModel.id), // Dynamic model selection
      system: "Write about the given topic...",
      prompt: title,
    });
    // ... streaming logic
  },
});
```

### 3. Image Generation

```typescript
// Reference: artifacts/image/server.ts - Gateway image models
export const imageDocumentHandler = createDocumentHandler<"image">({
  kind: "image",
  onCreateDocument: async ({ title, dataStream }) => {
    const { image } = await experimental_generateImage({
      model: gateway.imageModel(DEFAULT_IMAGE_MODEL), // Configurable image model
      prompt: title,
      n: 1,
    });
    // ... processing logic
  },
});
```

## Model Management Best Practices

### 1. Adding New Models

```typescript
// lib/constants.ts - Add to unified configuration
export const SUPPORTED_MODELS = {
  // ... existing models
  "anthropic/claude-3.5-haiku": {
    supportsReasoning: false,
    supportsArtifacts: true,
  },
} as const;
```

### 2. Capability-Based Features

```typescript
// Always check capabilities, never hardcode model names
const supportsArtifacts = modelSupports(selectedModelId, "artifacts");
const supportsReasoning = modelSupports(selectedModelId, "reasoning");

if (supportsArtifacts) {
  // Enable artifact tools
}

if (supportsReasoning) {
  // Show reasoning UI
}
```

### 3. Entitlements Configuration

```typescript
// Reference: lib/ai/entitlements.ts - Dynamic filtering
export const entitlementsByUserType: Record<UserType, Entitlements> = {
  guest: {
    maxMessagesPerDay: 20,
    getAllowedModelIds: () => {
      return SUPPORTED_MODEL_IDS.filter(
        (modelId) =>
          modelId.includes("grok-3-mini") || modelId.includes("gpt-3.5")
      );
    },
  },
  regular: {
    maxMessagesPerDay: 100,
    getAllowedModelIds: () => SUPPORTED_MODEL_IDS, // All models
  },
};
```

## Security Implementation

### 1. Model Access Validation

```typescript
// Always validate model access server-side
export function validateModelAccess(
  modelId: string,
  userType: UserType,
  userId: string,
  allowedModelIds: string[]
): void {
  if (!allowedModelIds.includes(modelId)) {
    logSecurityEvent("forbidden_model", {
      userId,
      userType,
      attemptedValue: modelId,
      allowedValues: allowedModelIds,
    });
    throw new ChatSDKError("forbidden:chat");
  }
}
```

### 2. Rate Limiting & Authentication

```typescript
// lib/security.ts - Enhanced security checks
export async function requireAuth(): Promise<SecurityContext> {
  const session = await auth();
  if (!session?.user?.id) throw new ChatSDKError("unauthorized:chat");

  // Database verification for real-time deactivation
  const dbUser = await getUserById(session.user.id);
  if (!dbUser) throw new ChatSDKError("unauthorized:chat");

  return {
    user: { id: session.user.id, type: session.user.type },
    isAuthenticated: true,
  };
}
```

## Testing Patterns

### 1. Model Configuration Testing

```typescript
describe("Gateway Integration", () => {
  it("should handle model capabilities correctly", () => {
    expect(modelSupports("xai/grok-3-mini", "reasoning")).toBe(true);
    expect(modelSupports("openai/gpt-3.5-turbo", "artifacts")).toBe(false);
  });

  it("should validate model access", () => {
    expect(() =>
      validateModelAccess("premium-model", "guest", "user-id", ["basic-model"])
    ).toThrow();
  });
});
```

### 2. API Security Testing

```typescript
describe("API Security", () => {
  it("should reject unauthorized model access", async () => {
    const response = await POST(
      createRequest({
        selectedChatModel: "premium-model",
        session: { user: { type: "guest" } },
      })
    );

    expect(response.status).toBe(403);
  });
});
```

## Migration Guidelines

### From Custom Provider to Gateway

1. **Replace provider imports**: Use `getLanguageModel()` instead of `myProvider.languageModel()`
2. **Update model references**: Use constants instead of hardcoded strings
3. **Implement capability checks**: Use `modelSupports()` for feature detection
4. **Add security validation**: Use `validateModelAccess()` for authorization
5. **Update client components**: Use `/api/models` for dynamic model listing

### Key Architecture Benefits

- ✅ **Unified Gateway**: All models through single AI SDK Gateway
- ✅ **No Hardcoding**: Models configured via constants
- ✅ **Server-Side Security**: Authentication + entitlement validation
- ✅ **Dynamic Capabilities**: Features based on model capabilities
- ✅ **Real-time Updates**: Models fetched fresh from gateway
- ✅ **Type Safety**: TypeScript ensures configuration consistency
